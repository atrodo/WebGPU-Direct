# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! #
#   This file is generated by webgpu.xs.PL  #
# !!!!!!!   ANY EDIT WILL BE LOST   !!!!!!! #

MODULE = WebGPU::Direct		PACKAGE = WebGPU::Direct::XS		PREFIX = wgpu

WGPUInstance 
wgpucreateInstance(descriptor)
        WGPUInstanceDescriptor const * descriptor
    CODE:
      RETVAL = wgpuCreateInstance(descriptor);
    OUTPUT:
      RETVAL


WGPUStatus 
wgpugetInstanceCapabilities(capabilities)
        WGPUInstanceCapabilities * capabilities
    CODE:
      RETVAL = wgpuGetInstanceCapabilities(capabilities);
      {
        SV *u = ST(0);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUProc 
wgpugetProcAddress(procName)
        WGPUStringView procName
    CODE:
      RETVAL = wgpuGetProcAddress(procName);
      {
        SV *u = ST(0);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::StringView	PREFIX = wgpu

SV *
data(THIS, value = NO_INIT)
        WebGPU::Direct::StringView THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStringView *n = (WGPUStringView *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_strview(aTHX_ h, "data", 4,  &n->data, &n->length, NULL);

        if (items > 1)
        {
              _store_strview(aTHX_ h, "data", 4,  &n->data, &n->length, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
length(THIS, value = NO_INIT)
        WebGPU::Direct::StringView THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStringView *n = (WGPUStringView *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "length", 6,  &n->length, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__StringView__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__StringView__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUStringView *n = (WGPUStringView *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUStringView) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Adapter	PREFIX = wgpuAdapter


void 
wgpuAdaptergetFeatures(adapter, features)
        WGPUAdapter adapter
        WGPUSupportedFeatures * features
    CODE:
      wgpuAdapterGetFeatures(adapter, features);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


WGPUStatus 
wgpuAdaptergetInfo(adapter, info)
        WGPUAdapter adapter
        WGPUAdapterInfo * info
    CODE:
      RETVAL = wgpuAdapterGetInfo(adapter, info);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUStatus 
wgpuAdaptergetLimits(adapter, limits)
        WGPUAdapter adapter
        WGPULimits * limits
    CODE:
      RETVAL = wgpuAdapterGetLimits(adapter, limits);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUBool 
wgpuAdapterhasFeature(adapter, feature)
        WGPUAdapter adapter
        WGPUFeatureName feature
    CODE:
      RETVAL = wgpuAdapterHasFeature(adapter, feature);
    OUTPUT:
      RETVAL


WGPUFuture 
wgpuAdapter_requestDevice(adapter, descriptor, callbackInfo)
        WGPUAdapter adapter
        WGPUDeviceDescriptor const * descriptor
        WGPURequestDeviceCallbackInfo callbackInfo
    CODE:
      WGPUDeviceDescriptor const * c = &WebGPU__Direct__DeviceDescriptor__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuAdapterRequestDevice(adapter, c, c_userdata);
      {
        SV *u = ST(2);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuAdapteraddRef(adapter)
        WGPUAdapter adapter
    CODE:
      wgpuAdapterAddRef(adapter);


void 
wgpuAdapterrelease(adapter)
        WGPUAdapter adapter
    CODE:
      wgpuAdapterRelease(adapter);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BindGroup	PREFIX = wgpuBindGroup


void 
wgpuBindGroupsetLabel(bindGroup, label)
        WGPUBindGroup bindGroup
        WGPUStringView label
    CODE:
      wgpuBindGroupSetLabel(bindGroup, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuBindGroupaddRef(bindGroup)
        WGPUBindGroup bindGroup
    CODE:
      wgpuBindGroupAddRef(bindGroup);


void 
wgpuBindGrouprelease(bindGroup)
        WGPUBindGroup bindGroup
    CODE:
      wgpuBindGroupRelease(bindGroup);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BindGroupLayout	PREFIX = wgpuBindGroupLayout


void 
wgpuBindGroupLayoutsetLabel(bindGroupLayout, label)
        WGPUBindGroupLayout bindGroupLayout
        WGPUStringView label
    CODE:
      wgpuBindGroupLayoutSetLabel(bindGroupLayout, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuBindGroupLayoutaddRef(bindGroupLayout)
        WGPUBindGroupLayout bindGroupLayout
    CODE:
      wgpuBindGroupLayoutAddRef(bindGroupLayout);


void 
wgpuBindGroupLayoutrelease(bindGroupLayout)
        WGPUBindGroupLayout bindGroupLayout
    CODE:
      wgpuBindGroupLayoutRelease(bindGroupLayout);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Buffer	PREFIX = wgpuBuffer


void 
wgpuBufferdestroy(buffer)
        WGPUBuffer buffer
    CODE:
      wgpuBufferDestroy(buffer);


void const * 
wgpuBuffer_getConstMappedRange(buffer, offset, size)
        WGPUBuffer buffer
        size_t offset
        size_t size
    CODE:
      RETVAL = wgpuBufferGetConstMappedRange(buffer, offset, size);
    OUTPUT:
      RETVAL


WGPUBufferMapState 
wgpuBuffergetMapState(buffer)
        WGPUBuffer buffer
    CODE:
      RETVAL = wgpuBufferGetMapState(buffer);
    OUTPUT:
      RETVAL


SV *
wgpuBuffer_getMappedRange(buffer, offset, size)
        WGPUBuffer buffer
        size_t offset
        size_t size
    CODE:
      void *n = wgpuBufferGetMappedRange(buffer, offset, size);
      RETVAL =  WebGPU__Direct__MappedBuffer__wrap(aTHX_ n, size-offset);
    OUTPUT:
      RETVAL


uint64_t 
wgpuBuffergetSize(buffer)
        WGPUBuffer buffer
    CODE:
      RETVAL = wgpuBufferGetSize(buffer);
    OUTPUT:
      RETVAL


WGPUBufferUsage 
wgpuBuffergetUsage(buffer)
        WGPUBuffer buffer
    CODE:
      RETVAL = wgpuBufferGetUsage(buffer);
    OUTPUT:
      RETVAL


WGPUFuture 
wgpuBuffer_mapAsync(buffer, mode, offset, size, callbackInfo)
        WGPUBuffer buffer
        WGPUMapMode mode
        size_t offset
        size_t size
        WGPUBufferMapCallbackInfo callbackInfo
    CODE:
      size_t c = &size_t__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuBufferMapAsync(buffer, mode, offset, c, c_userdata);
      {
        SV *u = ST(4);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuBuffersetLabel(buffer, label)
        WGPUBuffer buffer
        WGPUStringView label
    CODE:
      wgpuBufferSetLabel(buffer, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuBufferunmap(buffer)
        WGPUBuffer buffer
    CODE:
      wgpuBufferUnmap(buffer);


void 
wgpuBufferaddRef(buffer)
        WGPUBuffer buffer
    CODE:
      wgpuBufferAddRef(buffer);


void 
wgpuBufferrelease(buffer)
        WGPUBuffer buffer
    CODE:
      wgpuBufferRelease(buffer);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CommandBuffer	PREFIX = wgpuCommandBuffer


void 
wgpuCommandBuffersetLabel(commandBuffer, label)
        WGPUCommandBuffer commandBuffer
        WGPUStringView label
    CODE:
      wgpuCommandBufferSetLabel(commandBuffer, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuCommandBufferaddRef(commandBuffer)
        WGPUCommandBuffer commandBuffer
    CODE:
      wgpuCommandBufferAddRef(commandBuffer);


void 
wgpuCommandBufferrelease(commandBuffer)
        WGPUCommandBuffer commandBuffer
    CODE:
      wgpuCommandBufferRelease(commandBuffer);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CommandEncoder	PREFIX = wgpuCommandEncoder


WGPUComputePassEncoder 
wgpuCommandEncoder_beginComputePass(commandEncoder, descriptor)
        WGPUCommandEncoder commandEncoder
        WGPUComputePassDescriptor const * descriptor
    CODE:
      RETVAL = wgpuCommandEncoderBeginComputePass(commandEncoder, descriptor);
    OUTPUT:
      RETVAL


WGPURenderPassEncoder 
wgpuCommandEncoderbeginRenderPass(commandEncoder, descriptor)
        WGPUCommandEncoder commandEncoder
        WGPURenderPassDescriptor const * descriptor
    CODE:
      RETVAL = wgpuCommandEncoderBeginRenderPass(commandEncoder, descriptor);
    OUTPUT:
      RETVAL


void 
wgpuCommandEncoder_clearBuffer(commandEncoder, buffer, offset, size)
        WGPUCommandEncoder commandEncoder
        WGPUBuffer buffer
        uint64_t offset
        uint64_t size
    CODE:
      wgpuCommandEncoderClearBuffer(commandEncoder, buffer, offset, size);


void 
wgpuCommandEncodercopyBufferToBuffer(commandEncoder, source, sourceOffset, destination, destinationOffset, size)
        WGPUCommandEncoder commandEncoder
        WGPUBuffer source
        uint64_t sourceOffset
        WGPUBuffer destination
        uint64_t destinationOffset
        uint64_t size
    CODE:
      wgpuCommandEncoderCopyBufferToBuffer(commandEncoder, source, sourceOffset, destination, destinationOffset, size);


void 
wgpuCommandEncodercopyBufferToTexture(commandEncoder, source, destination, copySize)
        WGPUCommandEncoder commandEncoder
        WGPUTexelCopyBufferInfo const * source
        WGPUTexelCopyTextureInfo const * destination
        WGPUExtent3D const * copySize
    CODE:
      wgpuCommandEncoderCopyBufferToTexture(commandEncoder, source, destination, copySize);


void 
wgpuCommandEncodercopyTextureToBuffer(commandEncoder, source, destination, copySize)
        WGPUCommandEncoder commandEncoder
        WGPUTexelCopyTextureInfo const * source
        WGPUTexelCopyBufferInfo const * destination
        WGPUExtent3D const * copySize
    CODE:
      wgpuCommandEncoderCopyTextureToBuffer(commandEncoder, source, destination, copySize);


void 
wgpuCommandEncodercopyTextureToTexture(commandEncoder, source, destination, copySize)
        WGPUCommandEncoder commandEncoder
        WGPUTexelCopyTextureInfo const * source
        WGPUTexelCopyTextureInfo const * destination
        WGPUExtent3D const * copySize
    CODE:
      wgpuCommandEncoderCopyTextureToTexture(commandEncoder, source, destination, copySize);


WGPUCommandBuffer 
wgpuCommandEncoder_finish(commandEncoder, descriptor)
        WGPUCommandEncoder commandEncoder
        WGPUCommandBufferDescriptor const * descriptor
    CODE:
      RETVAL = wgpuCommandEncoderFinish(commandEncoder, descriptor);
    OUTPUT:
      RETVAL


void 
wgpuCommandEncoderinsertDebugMarker(commandEncoder, markerLabel)
        WGPUCommandEncoder commandEncoder
        WGPUStringView markerLabel
    CODE:
      wgpuCommandEncoderInsertDebugMarker(commandEncoder, markerLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuCommandEncoderpopDebugGroup(commandEncoder)
        WGPUCommandEncoder commandEncoder
    CODE:
      wgpuCommandEncoderPopDebugGroup(commandEncoder);


void 
wgpuCommandEncoderpushDebugGroup(commandEncoder, groupLabel)
        WGPUCommandEncoder commandEncoder
        WGPUStringView groupLabel
    CODE:
      wgpuCommandEncoderPushDebugGroup(commandEncoder, groupLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuCommandEncoderresolveQuerySet(commandEncoder, querySet, firstQuery, queryCount, destination, destinationOffset)
        WGPUCommandEncoder commandEncoder
        WGPUQuerySet querySet
        uint32_t firstQuery
        uint32_t queryCount
        WGPUBuffer destination
        uint64_t destinationOffset
    CODE:
      wgpuCommandEncoderResolveQuerySet(commandEncoder, querySet, firstQuery, queryCount, destination, destinationOffset);


void 
wgpuCommandEncodersetLabel(commandEncoder, label)
        WGPUCommandEncoder commandEncoder
        WGPUStringView label
    CODE:
      wgpuCommandEncoderSetLabel(commandEncoder, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuCommandEncoderwriteTimestamp(commandEncoder, querySet, queryIndex)
        WGPUCommandEncoder commandEncoder
        WGPUQuerySet querySet
        uint32_t queryIndex
    CODE:
      wgpuCommandEncoderWriteTimestamp(commandEncoder, querySet, queryIndex);


void 
wgpuCommandEncoderaddRef(commandEncoder)
        WGPUCommandEncoder commandEncoder
    CODE:
      wgpuCommandEncoderAddRef(commandEncoder);


void 
wgpuCommandEncoderrelease(commandEncoder)
        WGPUCommandEncoder commandEncoder
    CODE:
      wgpuCommandEncoderRelease(commandEncoder);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ComputePassEncoder	PREFIX = wgpuComputePassEncoder


void 
wgpuComputePassEncoderdispatchWorkgroups(computePassEncoder, workgroupCountX, workgroupCountY = 1, workgroupCountZ = 1)
        WGPUComputePassEncoder computePassEncoder
        uint32_t workgroupCountX
        uint32_t workgroupCountY
        uint32_t workgroupCountZ
    CODE:
      wgpuComputePassEncoderDispatchWorkgroups(computePassEncoder, workgroupCountX, workgroupCountY, workgroupCountZ);


void 
wgpuComputePassEncoderdispatchWorkgroupsIndirect(computePassEncoder, indirectBuffer, indirectOffset)
        WGPUComputePassEncoder computePassEncoder
        WGPUBuffer indirectBuffer
        uint64_t indirectOffset
    CODE:
      wgpuComputePassEncoderDispatchWorkgroupsIndirect(computePassEncoder, indirectBuffer, indirectOffset);


void 
wgpuComputePassEncoderend(computePassEncoder)
        WGPUComputePassEncoder computePassEncoder
    CODE:
      wgpuComputePassEncoderEnd(computePassEncoder);


void 
wgpuComputePassEncoderinsertDebugMarker(computePassEncoder, markerLabel)
        WGPUComputePassEncoder computePassEncoder
        WGPUStringView markerLabel
    CODE:
      wgpuComputePassEncoderInsertDebugMarker(computePassEncoder, markerLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuComputePassEncoderpopDebugGroup(computePassEncoder)
        WGPUComputePassEncoder computePassEncoder
    CODE:
      wgpuComputePassEncoderPopDebugGroup(computePassEncoder);


void 
wgpuComputePassEncoderpushDebugGroup(computePassEncoder, groupLabel)
        WGPUComputePassEncoder computePassEncoder
        WGPUStringView groupLabel
    CODE:
      wgpuComputePassEncoderPushDebugGroup(computePassEncoder, groupLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuComputePassEncoder_setBindGroup(computePassEncoder, groupIndex, group, dynamicOffsets)
        WGPUComputePassEncoder computePassEncoder
        uint32_t groupIndex
        WGPUBindGroup group
        AV * dynamicOffsets
    CODE:
      Size_t dynamicOffsetCount = av_count(dynamicOffsets);
      uint32_t   dynamicOffset[dynamicOffsetCount+1];
      for ( Size_t i = 0; i < dynamicOffsetCount; i++ )
      {
        SV **item = av_fetch(dynamicOffsets, i, 0);
        if ( *item != NULL )
        {
          uint32_t   n = SvIV(*item);
          dynamicOffset[i] = n;
        }
      }

      wgpuComputePassEncoderSetBindGroup(computePassEncoder, groupIndex, group, dynamicOffsetCount, dynamicOffset);


void 
wgpuComputePassEncodersetLabel(computePassEncoder, label)
        WGPUComputePassEncoder computePassEncoder
        WGPUStringView label
    CODE:
      wgpuComputePassEncoderSetLabel(computePassEncoder, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuComputePassEncodersetPipeline(computePassEncoder, pipeline)
        WGPUComputePassEncoder computePassEncoder
        WGPUComputePipeline pipeline
    CODE:
      wgpuComputePassEncoderSetPipeline(computePassEncoder, pipeline);


void 
wgpuComputePassEncoderaddRef(computePassEncoder)
        WGPUComputePassEncoder computePassEncoder
    CODE:
      wgpuComputePassEncoderAddRef(computePassEncoder);


void 
wgpuComputePassEncoderrelease(computePassEncoder)
        WGPUComputePassEncoder computePassEncoder
    CODE:
      wgpuComputePassEncoderRelease(computePassEncoder);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ComputePipeline	PREFIX = wgpuComputePipeline


WGPUBindGroupLayout 
wgpuComputePipelinegetBindGroupLayout(computePipeline, groupIndex)
        WGPUComputePipeline computePipeline
        uint32_t groupIndex
    CODE:
      RETVAL = wgpuComputePipelineGetBindGroupLayout(computePipeline, groupIndex);
    OUTPUT:
      RETVAL


void 
wgpuComputePipelinesetLabel(computePipeline, label)
        WGPUComputePipeline computePipeline
        WGPUStringView label
    CODE:
      wgpuComputePipelineSetLabel(computePipeline, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuComputePipelineaddRef(computePipeline)
        WGPUComputePipeline computePipeline
    CODE:
      wgpuComputePipelineAddRef(computePipeline);


void 
wgpuComputePipelinerelease(computePipeline)
        WGPUComputePipeline computePipeline
    CODE:
      wgpuComputePipelineRelease(computePipeline);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Device	PREFIX = wgpuDevice


WGPUBindGroup 
wgpuDevicecreateBindGroup(device, descriptor)
        WGPUDevice device
        WGPUBindGroupDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateBindGroup(device, descriptor);
    OUTPUT:
      RETVAL


WGPUBindGroupLayout 
wgpuDevicecreateBindGroupLayout(device, descriptor)
        WGPUDevice device
        WGPUBindGroupLayoutDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateBindGroupLayout(device, descriptor);
    OUTPUT:
      RETVAL


WGPUBuffer 
wgpuDevicecreateBuffer(device, descriptor)
        WGPUDevice device
        WGPUBufferDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateBuffer(device, descriptor);
    OUTPUT:
      RETVAL


WGPUCommandEncoder 
wgpuDevice_createCommandEncoder(device, descriptor)
        WGPUDevice device
        WGPUCommandEncoderDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateCommandEncoder(device, descriptor);
    OUTPUT:
      RETVAL


WGPUComputePipeline 
wgpuDevicecreateComputePipeline(device, descriptor)
        WGPUDevice device
        WGPUComputePipelineDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateComputePipeline(device, descriptor);
    OUTPUT:
      RETVAL


WGPUFuture 
wgpuDevicecreateComputePipelineAsync(device, descriptor, callbackInfo)
        WGPUDevice device
        WGPUComputePipelineDescriptor const * descriptor
        WGPUCreateComputePipelineAsyncCallbackInfo callbackInfo
    CODE:
      WGPUComputePipelineDescriptor const * c = &WebGPU__Direct__ComputePipelineDescriptor__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuDeviceCreateComputePipelineAsync(device, c, c_userdata);
      {
        SV *u = ST(2);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUPipelineLayout 
wgpuDevicecreatePipelineLayout(device, descriptor)
        WGPUDevice device
        WGPUPipelineLayoutDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreatePipelineLayout(device, descriptor);
    OUTPUT:
      RETVAL


WGPUQuerySet 
wgpuDevicecreateQuerySet(device, descriptor)
        WGPUDevice device
        WGPUQuerySetDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateQuerySet(device, descriptor);
    OUTPUT:
      RETVAL


WGPURenderBundleEncoder 
wgpuDevicecreateRenderBundleEncoder(device, descriptor)
        WGPUDevice device
        WGPURenderBundleEncoderDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateRenderBundleEncoder(device, descriptor);
    OUTPUT:
      RETVAL


WGPURenderPipeline 
wgpuDevicecreateRenderPipeline(device, descriptor)
        WGPUDevice device
        WGPURenderPipelineDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateRenderPipeline(device, descriptor);
    OUTPUT:
      RETVAL


WGPUFuture 
wgpuDevicecreateRenderPipelineAsync(device, descriptor, callbackInfo)
        WGPUDevice device
        WGPURenderPipelineDescriptor const * descriptor
        WGPUCreateRenderPipelineAsyncCallbackInfo callbackInfo
    CODE:
      WGPURenderPipelineDescriptor const * c = &WebGPU__Direct__RenderPipelineDescriptor__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuDeviceCreateRenderPipelineAsync(device, c, c_userdata);
      {
        SV *u = ST(2);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUSampler 
wgpuDevice_createSampler(device, descriptor)
        WGPUDevice device
        WGPUSamplerDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateSampler(device, descriptor);
    OUTPUT:
      RETVAL


WGPUShaderModule 
wgpuDevice_createShaderModule(device, descriptor)
        WGPUDevice device
        WGPUShaderModuleDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateShaderModule(device, descriptor);
    OUTPUT:
      RETVAL


WGPUTexture 
wgpuDevicecreateTexture(device, descriptor)
        WGPUDevice device
        WGPUTextureDescriptor const * descriptor
    CODE:
      RETVAL = wgpuDeviceCreateTexture(device, descriptor);
    OUTPUT:
      RETVAL


void 
wgpuDevicedestroy(device)
        WGPUDevice device
    CODE:
      wgpuDeviceDestroy(device);


WGPUAdapterInfo 
wgpuDevicegetAdapterInfo(device)
        WGPUDevice device
    CODE:
      RETVAL = wgpuDeviceGetAdapterInfo(device);
    OUTPUT:
      RETVAL


void 
wgpuDevicegetFeatures(device, features)
        WGPUDevice device
        WGPUSupportedFeatures * features
    CODE:
      wgpuDeviceGetFeatures(device, features);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


WGPUStatus 
wgpuDevicegetLimits(device, limits)
        WGPUDevice device
        WGPULimits * limits
    CODE:
      RETVAL = wgpuDeviceGetLimits(device, limits);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUFuture 
wgpuDevicegetLostFuture(device)
        WGPUDevice device
    CODE:
      RETVAL = wgpuDeviceGetLostFuture(device);
    OUTPUT:
      RETVAL


WGPUQueue 
wgpuDevicegetQueue(device)
        WGPUDevice device
    CODE:
      RETVAL = wgpuDeviceGetQueue(device);
    OUTPUT:
      RETVAL


WGPUBool 
wgpuDevicehasFeature(device, feature)
        WGPUDevice device
        WGPUFeatureName feature
    CODE:
      RETVAL = wgpuDeviceHasFeature(device, feature);
    OUTPUT:
      RETVAL


WGPUFuture 
wgpuDevicepopErrorScope(device, callbackInfo)
        WGPUDevice device
        WGPUPopErrorScopeCallbackInfo callbackInfo
    CODE:
      WGPUDevice c = &WebGPU__Direct__Device__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuDevicePopErrorScope(c, c_userdata);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuDevicepushErrorScope(device, filter)
        WGPUDevice device
        WGPUErrorFilter filter
    CODE:
      wgpuDevicePushErrorScope(device, filter);


void 
wgpuDevicesetLabel(device, label)
        WGPUDevice device
        WGPUStringView label
    CODE:
      wgpuDeviceSetLabel(device, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuDeviceaddRef(device)
        WGPUDevice device
    CODE:
      wgpuDeviceAddRef(device);


void 
wgpuDevicerelease(device)
        WGPUDevice device
    CODE:
      wgpuDeviceRelease(device);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Instance	PREFIX = wgpuInstance


WGPUSurface 
wgpuInstancecreateSurface(instance, descriptor)
        WGPUInstance instance
        WGPUSurfaceDescriptor const * descriptor
    CODE:
      RETVAL = wgpuInstanceCreateSurface(instance, descriptor);
    OUTPUT:
      RETVAL


WGPUStatus 
wgpuInstancegetWGSLLanguageFeatures(instance, features)
        WGPUInstance instance
        WGPUSupportedWGSLLanguageFeatures * features
    CODE:
      RETVAL = wgpuInstanceGetWGSLLanguageFeatures(instance, features);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUBool 
wgpuInstancehasWGSLLanguageFeature(instance, feature)
        WGPUInstance instance
        WGPUWGSLLanguageFeatureName feature
    CODE:
      RETVAL = wgpuInstanceHasWGSLLanguageFeature(instance, feature);
    OUTPUT:
      RETVAL


void 
wgpuInstanceprocessEvents(instance)
        WGPUInstance instance
    CODE:
      wgpuInstanceProcessEvents(instance);


WGPUFuture 
wgpuInstance_requestAdapter(instance, options, callbackInfo)
        WGPUInstance instance
        WGPURequestAdapterOptions const * options
        WGPURequestAdapterCallbackInfo callbackInfo
    CODE:
      WGPURequestAdapterOptions const * c = &WebGPU__Direct__RequestAdapterOptions__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuInstanceRequestAdapter(instance, c, c_userdata);
      {
        SV *u = ST(2);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


WGPUWaitStatus 
wgpuInstancewaitAny(instance, futures, timeoutNS)
        WGPUInstance instance
        AV * futures
        uint64_t timeoutNS
    CODE:
      Size_t futureCount = av_count(futures);
      WGPUFutureWaitInfo  future[futureCount+1];
      for ( Size_t i = 0; i < futureCount; i++ )
      {
        SV **item = av_fetch(futures, i, 0);
        if ( *item != NULL )
        {
          WGPUFutureWaitInfo  n = *(WGPUFutureWaitInfo  *) _get_struct_ptr(aTHX_ *item, NULL);
          future[i] = n;
        }
      }

      RETVAL = wgpuInstanceWaitAny(instance, futureCount, future, timeoutNS);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuInstanceaddRef(instance)
        WGPUInstance instance
    CODE:
      wgpuInstanceAddRef(instance);


void 
wgpuInstancerelease(instance)
        WGPUInstance instance
    CODE:
      wgpuInstanceRelease(instance);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::PipelineLayout	PREFIX = wgpuPipelineLayout


void 
wgpuPipelineLayoutsetLabel(pipelineLayout, label)
        WGPUPipelineLayout pipelineLayout
        WGPUStringView label
    CODE:
      wgpuPipelineLayoutSetLabel(pipelineLayout, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuPipelineLayoutaddRef(pipelineLayout)
        WGPUPipelineLayout pipelineLayout
    CODE:
      wgpuPipelineLayoutAddRef(pipelineLayout);


void 
wgpuPipelineLayoutrelease(pipelineLayout)
        WGPUPipelineLayout pipelineLayout
    CODE:
      wgpuPipelineLayoutRelease(pipelineLayout);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::QuerySet	PREFIX = wgpuQuerySet


void 
wgpuQuerySetdestroy(querySet)
        WGPUQuerySet querySet
    CODE:
      wgpuQuerySetDestroy(querySet);


uint32_t 
wgpuQuerySetgetCount(querySet)
        WGPUQuerySet querySet
    CODE:
      RETVAL = wgpuQuerySetGetCount(querySet);
    OUTPUT:
      RETVAL


WGPUQueryType 
wgpuQuerySetgetType(querySet)
        WGPUQuerySet querySet
    CODE:
      RETVAL = wgpuQuerySetGetType(querySet);
    OUTPUT:
      RETVAL


void 
wgpuQuerySetsetLabel(querySet, label)
        WGPUQuerySet querySet
        WGPUStringView label
    CODE:
      wgpuQuerySetSetLabel(querySet, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuQuerySetaddRef(querySet)
        WGPUQuerySet querySet
    CODE:
      wgpuQuerySetAddRef(querySet);


void 
wgpuQuerySetrelease(querySet)
        WGPUQuerySet querySet
    CODE:
      wgpuQuerySetRelease(querySet);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Queue	PREFIX = wgpuQueue


WGPUFuture 
wgpuQueueonSubmittedWorkDone(queue, callbackInfo)
        WGPUQueue queue
        WGPUQueueWorkDoneCallbackInfo callbackInfo
    CODE:
      WGPUQueue c = &WebGPU__Direct__Queue__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuQueueOnSubmittedWorkDone(c, c_userdata);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuQueuesetLabel(queue, label)
        WGPUQueue queue
        WGPUStringView label
    CODE:
      wgpuQueueSetLabel(queue, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuQueuesubmit(queue, commands)
        WGPUQueue queue
        AV * commands
    CODE:
      Size_t commandCount = av_count(commands);
      WGPUCommandBuffer   command[commandCount+1];
      for ( Size_t i = 0; i < commandCount; i++ )
      {
        SV **item = av_fetch(commands, i, 0);
        if ( *item != NULL )
        {
          WGPUCommandBuffer   n = (WGPUCommandBuffer  ) _get_struct_ptr(aTHX_ *item, NULL);
          command[i] = n;
        }
      }

      command[commandCount+1] = (WGPUCommandBuffer  ) 0;
      wgpuQueueSubmit(queue, commandCount, command);


void 
wgpuQueuewriteBuffer(queue, buffer, bufferOffset, data)
        WGPUQueue queue
        WGPUBuffer buffer
        uint64_t bufferOffset
        SV * data
    CODE:
      STRLEN dataSize;
      const char *dataData = SvPV_const(data, dataSize);

      wgpuQueueWriteBuffer(queue, buffer, bufferOffset, dataData, dataSize);


void 
wgpuQueuewriteTexture(queue, destination, data, dataLayout, writeSize)
        WGPUQueue queue
        WGPUTexelCopyTextureInfo const * destination
        SV * data
        WGPUTexelCopyBufferLayout const * dataLayout
        WGPUExtent3D const * writeSize
    CODE:
      STRLEN dataSize;
      const char *dataData = SvPV_const(data, dataSize);

      wgpuQueueWriteTexture(queue, destination, dataData, dataSize, dataLayout, writeSize);


void 
wgpuQueueaddRef(queue)
        WGPUQueue queue
    CODE:
      wgpuQueueAddRef(queue);


void 
wgpuQueuerelease(queue)
        WGPUQueue queue
    CODE:
      wgpuQueueRelease(queue);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderBundle	PREFIX = wgpuRenderBundle


void 
wgpuRenderBundlesetLabel(renderBundle, label)
        WGPURenderBundle renderBundle
        WGPUStringView label
    CODE:
      wgpuRenderBundleSetLabel(renderBundle, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderBundleaddRef(renderBundle)
        WGPURenderBundle renderBundle
    CODE:
      wgpuRenderBundleAddRef(renderBundle);


void 
wgpuRenderBundlerelease(renderBundle)
        WGPURenderBundle renderBundle
    CODE:
      wgpuRenderBundleRelease(renderBundle);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderBundleEncoder	PREFIX = wgpuRenderBundleEncoder


void 
wgpuRenderBundleEncoderdraw(renderBundleEncoder, vertexCount, instanceCount = 1, firstVertex = 0, firstInstance = 0)
        WGPURenderBundleEncoder renderBundleEncoder
        uint32_t vertexCount
        uint32_t instanceCount
        uint32_t firstVertex
        uint32_t firstInstance
    CODE:
      wgpuRenderBundleEncoderDraw(renderBundleEncoder, vertexCount, instanceCount, firstVertex, firstInstance);


void 
wgpuRenderBundleEncoderdrawIndexed(renderBundleEncoder, indexCount, instanceCount = 1, firstIndex = 0, baseVertex = 0, firstInstance = 0)
        WGPURenderBundleEncoder renderBundleEncoder
        uint32_t indexCount
        uint32_t instanceCount
        uint32_t firstIndex
        int32_t baseVertex
        uint32_t firstInstance
    CODE:
      wgpuRenderBundleEncoderDrawIndexed(renderBundleEncoder, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);


void 
wgpuRenderBundleEncoderdrawIndexedIndirect(renderBundleEncoder, indirectBuffer, indirectOffset)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPUBuffer indirectBuffer
        uint64_t indirectOffset
    CODE:
      wgpuRenderBundleEncoderDrawIndexedIndirect(renderBundleEncoder, indirectBuffer, indirectOffset);


void 
wgpuRenderBundleEncoderdrawIndirect(renderBundleEncoder, indirectBuffer, indirectOffset)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPUBuffer indirectBuffer
        uint64_t indirectOffset
    CODE:
      wgpuRenderBundleEncoderDrawIndirect(renderBundleEncoder, indirectBuffer, indirectOffset);


WGPURenderBundle 
wgpuRenderBundleEncoderfinish(renderBundleEncoder, descriptor)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPURenderBundleDescriptor const * descriptor
    CODE:
      RETVAL = wgpuRenderBundleEncoderFinish(renderBundleEncoder, descriptor);
    OUTPUT:
      RETVAL


void 
wgpuRenderBundleEncoderinsertDebugMarker(renderBundleEncoder, markerLabel)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPUStringView markerLabel
    CODE:
      wgpuRenderBundleEncoderInsertDebugMarker(renderBundleEncoder, markerLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderBundleEncoderpopDebugGroup(renderBundleEncoder)
        WGPURenderBundleEncoder renderBundleEncoder
    CODE:
      wgpuRenderBundleEncoderPopDebugGroup(renderBundleEncoder);


void 
wgpuRenderBundleEncoderpushDebugGroup(renderBundleEncoder, groupLabel)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPUStringView groupLabel
    CODE:
      wgpuRenderBundleEncoderPushDebugGroup(renderBundleEncoder, groupLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderBundleEncoder_setBindGroup(renderBundleEncoder, groupIndex, group, dynamicOffsets)
        WGPURenderBundleEncoder renderBundleEncoder
        uint32_t groupIndex
        WGPUBindGroup group
        AV * dynamicOffsets
    CODE:
      Size_t dynamicOffsetCount = av_count(dynamicOffsets);
      uint32_t   dynamicOffset[dynamicOffsetCount+1];
      for ( Size_t i = 0; i < dynamicOffsetCount; i++ )
      {
        SV **item = av_fetch(dynamicOffsets, i, 0);
        if ( *item != NULL )
        {
          uint32_t   n = SvIV(*item);
          dynamicOffset[i] = n;
        }
      }

      wgpuRenderBundleEncoderSetBindGroup(renderBundleEncoder, groupIndex, group, dynamicOffsetCount, dynamicOffset);


void 
wgpuRenderBundleEncoder_setIndexBuffer(renderBundleEncoder, buffer, format, offset, size)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPUBuffer buffer
        WGPUIndexFormat format
        uint64_t offset
        uint64_t size
    CODE:
      wgpuRenderBundleEncoderSetIndexBuffer(renderBundleEncoder, buffer, format, offset, size);


void 
wgpuRenderBundleEncodersetLabel(renderBundleEncoder, label)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPUStringView label
    CODE:
      wgpuRenderBundleEncoderSetLabel(renderBundleEncoder, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderBundleEncodersetPipeline(renderBundleEncoder, pipeline)
        WGPURenderBundleEncoder renderBundleEncoder
        WGPURenderPipeline pipeline
    CODE:
      wgpuRenderBundleEncoderSetPipeline(renderBundleEncoder, pipeline);


void 
wgpuRenderBundleEncoder_setVertexBuffer(renderBundleEncoder, slot, buffer, offset, size)
        WGPURenderBundleEncoder renderBundleEncoder
        uint32_t slot
        WGPUBuffer buffer
        uint64_t offset
        uint64_t size
    CODE:
      wgpuRenderBundleEncoderSetVertexBuffer(renderBundleEncoder, slot, buffer, offset, size);


void 
wgpuRenderBundleEncoderaddRef(renderBundleEncoder)
        WGPURenderBundleEncoder renderBundleEncoder
    CODE:
      wgpuRenderBundleEncoderAddRef(renderBundleEncoder);


void 
wgpuRenderBundleEncoderrelease(renderBundleEncoder)
        WGPURenderBundleEncoder renderBundleEncoder
    CODE:
      wgpuRenderBundleEncoderRelease(renderBundleEncoder);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPassEncoder	PREFIX = wgpuRenderPassEncoder


void 
wgpuRenderPassEncoderbeginOcclusionQuery(renderPassEncoder, queryIndex)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t queryIndex
    CODE:
      wgpuRenderPassEncoderBeginOcclusionQuery(renderPassEncoder, queryIndex);


void 
wgpuRenderPassEncoderdraw(renderPassEncoder, vertexCount, instanceCount = 1, firstVertex = 0, firstInstance = 0)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t vertexCount
        uint32_t instanceCount
        uint32_t firstVertex
        uint32_t firstInstance
    CODE:
      wgpuRenderPassEncoderDraw(renderPassEncoder, vertexCount, instanceCount, firstVertex, firstInstance);


void 
wgpuRenderPassEncoderdrawIndexed(renderPassEncoder, indexCount, instanceCount = 1, firstIndex = 0, baseVertex = 0, firstInstance = 0)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t indexCount
        uint32_t instanceCount
        uint32_t firstIndex
        int32_t baseVertex
        uint32_t firstInstance
    CODE:
      wgpuRenderPassEncoderDrawIndexed(renderPassEncoder, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);


void 
wgpuRenderPassEncoderdrawIndexedIndirect(renderPassEncoder, indirectBuffer, indirectOffset)
        WGPURenderPassEncoder renderPassEncoder
        WGPUBuffer indirectBuffer
        uint64_t indirectOffset
    CODE:
      wgpuRenderPassEncoderDrawIndexedIndirect(renderPassEncoder, indirectBuffer, indirectOffset);


void 
wgpuRenderPassEncoderdrawIndirect(renderPassEncoder, indirectBuffer, indirectOffset)
        WGPURenderPassEncoder renderPassEncoder
        WGPUBuffer indirectBuffer
        uint64_t indirectOffset
    CODE:
      wgpuRenderPassEncoderDrawIndirect(renderPassEncoder, indirectBuffer, indirectOffset);


void 
wgpuRenderPassEncoderend(renderPassEncoder)
        WGPURenderPassEncoder renderPassEncoder
    CODE:
      wgpuRenderPassEncoderEnd(renderPassEncoder);


void 
wgpuRenderPassEncoderendOcclusionQuery(renderPassEncoder)
        WGPURenderPassEncoder renderPassEncoder
    CODE:
      wgpuRenderPassEncoderEndOcclusionQuery(renderPassEncoder);


void 
wgpuRenderPassEncoderexecuteBundles(renderPassEncoder, bundles)
        WGPURenderPassEncoder renderPassEncoder
        AV * bundles
    CODE:
      Size_t bundleCount = av_count(bundles);
      WGPURenderBundle   bundle[bundleCount+1];
      for ( Size_t i = 0; i < bundleCount; i++ )
      {
        SV **item = av_fetch(bundles, i, 0);
        if ( *item != NULL )
        {
          WGPURenderBundle   n = (WGPURenderBundle  ) _get_struct_ptr(aTHX_ *item, NULL);
          bundle[i] = n;
        }
      }

      bundle[bundleCount+1] = (WGPURenderBundle  ) 0;
      wgpuRenderPassEncoderExecuteBundles(renderPassEncoder, bundleCount, bundle);


void 
wgpuRenderPassEncoderinsertDebugMarker(renderPassEncoder, markerLabel)
        WGPURenderPassEncoder renderPassEncoder
        WGPUStringView markerLabel
    CODE:
      wgpuRenderPassEncoderInsertDebugMarker(renderPassEncoder, markerLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderPassEncoderpopDebugGroup(renderPassEncoder)
        WGPURenderPassEncoder renderPassEncoder
    CODE:
      wgpuRenderPassEncoderPopDebugGroup(renderPassEncoder);


void 
wgpuRenderPassEncoderpushDebugGroup(renderPassEncoder, groupLabel)
        WGPURenderPassEncoder renderPassEncoder
        WGPUStringView groupLabel
    CODE:
      wgpuRenderPassEncoderPushDebugGroup(renderPassEncoder, groupLabel);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderPassEncoder_setBindGroup(renderPassEncoder, groupIndex, group, dynamicOffsets)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t groupIndex
        WGPUBindGroup group
        AV * dynamicOffsets
    CODE:
      Size_t dynamicOffsetCount = av_count(dynamicOffsets);
      uint32_t   dynamicOffset[dynamicOffsetCount+1];
      for ( Size_t i = 0; i < dynamicOffsetCount; i++ )
      {
        SV **item = av_fetch(dynamicOffsets, i, 0);
        if ( *item != NULL )
        {
          uint32_t   n = SvIV(*item);
          dynamicOffset[i] = n;
        }
      }

      wgpuRenderPassEncoderSetBindGroup(renderPassEncoder, groupIndex, group, dynamicOffsetCount, dynamicOffset);


void 
wgpuRenderPassEncodersetBlendConstant(renderPassEncoder, color)
        WGPURenderPassEncoder renderPassEncoder
        WGPUColor const * color
    CODE:
      wgpuRenderPassEncoderSetBlendConstant(renderPassEncoder, color);


void 
wgpuRenderPassEncoder_setIndexBuffer(renderPassEncoder, buffer, format, offset, size)
        WGPURenderPassEncoder renderPassEncoder
        WGPUBuffer buffer
        WGPUIndexFormat format
        uint64_t offset
        uint64_t size
    CODE:
      wgpuRenderPassEncoderSetIndexBuffer(renderPassEncoder, buffer, format, offset, size);


void 
wgpuRenderPassEncodersetLabel(renderPassEncoder, label)
        WGPURenderPassEncoder renderPassEncoder
        WGPUStringView label
    CODE:
      wgpuRenderPassEncoderSetLabel(renderPassEncoder, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderPassEncodersetPipeline(renderPassEncoder, pipeline)
        WGPURenderPassEncoder renderPassEncoder
        WGPURenderPipeline pipeline
    CODE:
      wgpuRenderPassEncoderSetPipeline(renderPassEncoder, pipeline);


void 
wgpuRenderPassEncodersetScissorRect(renderPassEncoder, x, y, width, height)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t x
        uint32_t y
        uint32_t width
        uint32_t height
    CODE:
      wgpuRenderPassEncoderSetScissorRect(renderPassEncoder, x, y, width, height);


void 
wgpuRenderPassEncodersetStencilReference(renderPassEncoder, reference)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t reference
    CODE:
      wgpuRenderPassEncoderSetStencilReference(renderPassEncoder, reference);


void 
wgpuRenderPassEncoder_setVertexBuffer(renderPassEncoder, slot, buffer, offset, size)
        WGPURenderPassEncoder renderPassEncoder
        uint32_t slot
        WGPUBuffer buffer
        uint64_t offset
        uint64_t size
    CODE:
      wgpuRenderPassEncoderSetVertexBuffer(renderPassEncoder, slot, buffer, offset, size);


void 
wgpuRenderPassEncodersetViewport(renderPassEncoder, x, y, width, height, minDepth, maxDepth)
        WGPURenderPassEncoder renderPassEncoder
        float x
        float y
        float width
        float height
        float minDepth
        float maxDepth
    CODE:
      wgpuRenderPassEncoderSetViewport(renderPassEncoder, x, y, width, height, minDepth, maxDepth);


void 
wgpuRenderPassEncoderaddRef(renderPassEncoder)
        WGPURenderPassEncoder renderPassEncoder
    CODE:
      wgpuRenderPassEncoderAddRef(renderPassEncoder);


void 
wgpuRenderPassEncoderrelease(renderPassEncoder)
        WGPURenderPassEncoder renderPassEncoder
    CODE:
      wgpuRenderPassEncoderRelease(renderPassEncoder);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPipeline	PREFIX = wgpuRenderPipeline


WGPUBindGroupLayout 
wgpuRenderPipelinegetBindGroupLayout(renderPipeline, groupIndex)
        WGPURenderPipeline renderPipeline
        uint32_t groupIndex
    CODE:
      RETVAL = wgpuRenderPipelineGetBindGroupLayout(renderPipeline, groupIndex);
    OUTPUT:
      RETVAL


void 
wgpuRenderPipelinesetLabel(renderPipeline, label)
        WGPURenderPipeline renderPipeline
        WGPUStringView label
    CODE:
      wgpuRenderPipelineSetLabel(renderPipeline, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuRenderPipelineaddRef(renderPipeline)
        WGPURenderPipeline renderPipeline
    CODE:
      wgpuRenderPipelineAddRef(renderPipeline);


void 
wgpuRenderPipelinerelease(renderPipeline)
        WGPURenderPipeline renderPipeline
    CODE:
      wgpuRenderPipelineRelease(renderPipeline);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Sampler	PREFIX = wgpuSampler


void 
wgpuSamplersetLabel(sampler, label)
        WGPUSampler sampler
        WGPUStringView label
    CODE:
      wgpuSamplerSetLabel(sampler, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuSampleraddRef(sampler)
        WGPUSampler sampler
    CODE:
      wgpuSamplerAddRef(sampler);


void 
wgpuSamplerrelease(sampler)
        WGPUSampler sampler
    CODE:
      wgpuSamplerRelease(sampler);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ShaderModule	PREFIX = wgpuShaderModule


WGPUFuture 
wgpuShaderModulegetCompilationInfo(shaderModule, callbackInfo)
        WGPUShaderModule shaderModule
        WGPUCompilationInfoCallbackInfo callbackInfo
    CODE:
      WGPUShaderModule c = &WebGPU__Direct__ShaderModule__callback;
      cb_data *c_userdata;
      Newx(c_userdata, 1, cb_data);
      *c_userdata = (cb_data) {
        .guard1 = CB_GUARD,
        .guard2 = CB_GUARD,
        .perlsub = callback,
        .data = userdata,
      };
      SvREFCNT_inc(callback);
      SvREFCNT_inc(userdata);

      RETVAL = wgpuShaderModuleGetCompilationInfo(c, c_userdata);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuShaderModulesetLabel(shaderModule, label)
        WGPUShaderModule shaderModule
        WGPUStringView label
    CODE:
      wgpuShaderModuleSetLabel(shaderModule, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuShaderModuleaddRef(shaderModule)
        WGPUShaderModule shaderModule
    CODE:
      wgpuShaderModuleAddRef(shaderModule);


void 
wgpuShaderModulerelease(shaderModule)
        WGPUShaderModule shaderModule
    CODE:
      wgpuShaderModuleRelease(shaderModule);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Surface	PREFIX = wgpuSurface


void 
wgpuSurfaceconfigure(surface, config)
        WGPUSurface surface
        WGPUSurfaceConfiguration const * config
    CODE:
      wgpuSurfaceConfigure(surface, config);


WGPUStatus 
wgpuSurfacegetCapabilities(surface, adapter, capabilities)
        WGPUSurface surface
        WGPUAdapter adapter
        WGPUSurfaceCapabilities * capabilities
    CODE:
      RETVAL = wgpuSurfaceGetCapabilities(surface, adapter, capabilities);
      {
        SV *u = ST(2);
        if ( sv_isobject(u) ) { _unpack(u); }
      }
    OUTPUT:
      RETVAL


void 
wgpuSurface_getCurrentTexture(surface, surfaceTexture)
        WGPUSurface surface
        WGPUSurfaceTexture * surfaceTexture
    CODE:
      wgpuSurfaceGetCurrentTexture(surface, surfaceTexture);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


WGPUStatus 
wgpuSurfacepresent(surface)
        WGPUSurface surface
    CODE:
      RETVAL = wgpuSurfacePresent(surface);
    OUTPUT:
      RETVAL


void 
wgpuSurfacesetLabel(surface, label)
        WGPUSurface surface
        WGPUStringView label
    CODE:
      wgpuSurfaceSetLabel(surface, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuSurfaceunconfigure(surface)
        WGPUSurface surface
    CODE:
      wgpuSurfaceUnconfigure(surface);


void 
wgpuSurfaceaddRef(surface)
        WGPUSurface surface
    CODE:
      wgpuSurfaceAddRef(surface);


void 
wgpuSurfacerelease(surface)
        WGPUSurface surface
    CODE:
      wgpuSurfaceRelease(surface);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Texture	PREFIX = wgpuTexture


WGPUTextureView 
wgpuTexture_createView(texture, descriptor)
        WGPUTexture texture
        WGPUTextureViewDescriptor const * descriptor
    CODE:
      RETVAL = wgpuTextureCreateView(texture, descriptor);
    OUTPUT:
      RETVAL


void 
wgpuTexturedestroy(texture)
        WGPUTexture texture
    CODE:
      wgpuTextureDestroy(texture);


uint32_t 
wgpuTexturegetDepthOrArrayLayers(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetDepthOrArrayLayers(texture);
    OUTPUT:
      RETVAL


WGPUTextureDimension 
wgpuTexturegetDimension(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetDimension(texture);
    OUTPUT:
      RETVAL


WGPUTextureFormat 
wgpuTexturegetFormat(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetFormat(texture);
    OUTPUT:
      RETVAL


uint32_t 
wgpuTexturegetHeight(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetHeight(texture);
    OUTPUT:
      RETVAL


uint32_t 
wgpuTexturegetMipLevelCount(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetMipLevelCount(texture);
    OUTPUT:
      RETVAL


uint32_t 
wgpuTexturegetSampleCount(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetSampleCount(texture);
    OUTPUT:
      RETVAL


WGPUTextureUsage 
wgpuTexturegetUsage(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetUsage(texture);
    OUTPUT:
      RETVAL


uint32_t 
wgpuTexturegetWidth(texture)
        WGPUTexture texture
    CODE:
      RETVAL = wgpuTextureGetWidth(texture);
    OUTPUT:
      RETVAL


void 
wgpuTexturesetLabel(texture, label)
        WGPUTexture texture
        WGPUStringView label
    CODE:
      wgpuTextureSetLabel(texture, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuTextureaddRef(texture)
        WGPUTexture texture
    CODE:
      wgpuTextureAddRef(texture);


void 
wgpuTexturerelease(texture)
        WGPUTexture texture
    CODE:
      wgpuTextureRelease(texture);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TextureView	PREFIX = wgpuTextureView


void 
wgpuTextureViewsetLabel(textureView, label)
        WGPUTextureView textureView
        WGPUStringView label
    CODE:
      wgpuTextureViewSetLabel(textureView, label);
      {
        SV *u = ST(1);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


void 
wgpuTextureViewaddRef(textureView)
        WGPUTextureView textureView
    CODE:
      wgpuTextureViewAddRef(textureView);


void 
wgpuTextureViewrelease(textureView)
        WGPUTextureView textureView
    CODE:
      wgpuTextureViewRelease(textureView);


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Proc	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BufferMapCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CompilationInfoCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CreateComputePipelineAsyncCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CreateRenderPipelineAsyncCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::DeviceLostCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::PopErrorScopeCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::QueueWorkDoneCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RequestAdapterCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RequestDeviceCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::UncapturedErrorCallback	PREFIX = wgpu


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ChainedStruct	PREFIX = wgpu

SV *
next(THIS, value = NO_INIT)
        WebGPU::Direct::ChainedStruct THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUChainedStruct *n = (WGPUChainedStruct *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sType(THIS, value = NO_INIT)
        WebGPU::Direct::ChainedStruct THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUChainedStruct *n = (WGPUChainedStruct *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ChainedStruct__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ChainedStruct__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUChainedStruct *n = (WGPUChainedStruct *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUChainedStruct) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ChainedStructOut	PREFIX = wgpu

SV *
next(THIS, value = NO_INIT)
        WebGPU::Direct::ChainedStructOut THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUChainedStructOut *n = (WGPUChainedStructOut *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStructOut"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "next", 4, (void **) &n->next, newSVpvs("WebGPU::Direct::ChainedStructOut"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sType(THIS, value = NO_INIT)
        WebGPU::Direct::ChainedStructOut THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUChainedStructOut *n = (WGPUChainedStructOut *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "sType", 5,  &n->sType, newSVpvs("WebGPU::Direct::SType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ChainedStructOut__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ChainedStructOut__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUChainedStructOut *n = (WGPUChainedStructOut *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUChainedStructOut) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BufferMapCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BufferMapCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::BufferMapCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::BufferMapCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::BufferMapCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BufferMapCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BufferMapCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBufferMapCallbackInfo *n = (WGPUBufferMapCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBufferMapCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CompilationInfoCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfoCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfoCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfoCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfoCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CompilationInfoCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CompilationInfoCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCompilationInfoCallbackInfo *n = (WGPUCompilationInfoCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCompilationInfoCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::CreateComputePipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CreateComputePipelineAsyncCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CreateComputePipelineAsyncCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCreateComputePipelineAsyncCallbackInfo *n = (WGPUCreateComputePipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCreateComputePipelineAsyncCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::CreateRenderPipelineAsyncCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CreateRenderPipelineAsyncCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CreateRenderPipelineAsyncCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCreateRenderPipelineAsyncCallbackInfo *n = (WGPUCreateRenderPipelineAsyncCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCreateRenderPipelineAsyncCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::DeviceLostCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceLostCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceLostCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceLostCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceLostCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__DeviceLostCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__DeviceLostCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUDeviceLostCallbackInfo *n = (WGPUDeviceLostCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUDeviceLostCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::PopErrorScopeCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::PopErrorScopeCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::PopErrorScopeCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::PopErrorScopeCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::PopErrorScopeCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__PopErrorScopeCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__PopErrorScopeCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUPopErrorScopeCallbackInfo *n = (WGPUPopErrorScopeCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUPopErrorScopeCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::QueueWorkDoneCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::QueueWorkDoneCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::QueueWorkDoneCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::QueueWorkDoneCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::QueueWorkDoneCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__QueueWorkDoneCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__QueueWorkDoneCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUQueueWorkDoneCallbackInfo *n = (WGPUQueueWorkDoneCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUQueueWorkDoneCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RequestAdapterCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RequestAdapterCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RequestAdapterCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURequestAdapterCallbackInfo *n = (WGPURequestAdapterCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURequestAdapterCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RequestDeviceCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RequestDeviceCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mode(THIS, value = NO_INIT)
        WebGPU::Direct::RequestDeviceCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mode", 4,  &n->mode, newSVpvs("WebGPU::Direct::CallbackMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::RequestDeviceCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::RequestDeviceCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RequestDeviceCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RequestDeviceCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURequestDeviceCallbackInfo *n = (WGPURequestDeviceCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURequestDeviceCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::UncapturedErrorCallbackInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::UncapturedErrorCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUUncapturedErrorCallbackInfo *n = (WGPUUncapturedErrorCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
callback(THIS, value = NO_INIT)
        WebGPU::Direct::UncapturedErrorCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUUncapturedErrorCallbackInfo *n = (WGPUUncapturedErrorCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL);

        if (items > 1)
        {
              _store_CODE(aTHX_ h, "callback", 8,  &n->userdata1, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
userdata(THIS, value = NO_INIT)
        WebGPU::Direct::UncapturedErrorCallbackInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUUncapturedErrorCallbackInfo *n = (WGPUUncapturedErrorCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL);

        if (items > 1)
        {
              _store_SV(aTHX_ h, "userdata", 8,  &n->userdata2, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__UncapturedErrorCallbackInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__UncapturedErrorCallbackInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUUncapturedErrorCallbackInfo *n = (WGPUUncapturedErrorCallbackInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUUncapturedErrorCallbackInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::AdapterInfo	PREFIX = wgpuAdapterInfo

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
vendor(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "vendor", 6,  &n->vendor, sizeof(n->vendor), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "vendor", 6,  &n->vendor, sizeof(n->vendor), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
architecture(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "architecture", 12,  &n->architecture, sizeof(n->architecture), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "architecture", 12,  &n->architecture, sizeof(n->architecture), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
device(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "device", 6,  &n->device, sizeof(n->device), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "device", 6,  &n->device, sizeof(n->device), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
description(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "description", 11,  &n->description, sizeof(n->description), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "description", 11,  &n->description, sizeof(n->description), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
backendType(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
adapterType(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "adapterType", 11,  &n->adapterType, newSVpvs("WebGPU::Direct::AdapterType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "adapterType", 11,  &n->adapterType, newSVpvs("WebGPU::Direct::AdapterType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
vendorID(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "vendorID", 8,  &n->vendorID, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "vendorID", 8,  &n->vendorID, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
deviceID(THIS, value = NO_INIT)
        WebGPU::Direct::AdapterInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "deviceID", 8,  &n->deviceID, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "deviceID", 8,  &n->deviceID, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__AdapterInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__AdapterInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUAdapterInfo *n = (WGPUAdapterInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUAdapterInfo) );
    OUTPUT:
        RETVAL


void 
wgpuAdapterInfofreeMembers(adapterInfo)
        WGPUAdapterInfo adapterInfo
    CODE:
      wgpuAdapterInfoFreeMembers(adapterInfo);
      {
        SV *u = ST(0);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BindGroupEntry	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
binding(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
buffer(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
offset(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
size(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sampler(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "sampler", 7, (void **) &n->sampler, newSVpvs("WebGPU::Direct::Sampler"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "sampler", 7, (void **) &n->sampler, newSVpvs("WebGPU::Direct::Sampler"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
textureView(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "textureView", 11, (void **) &n->textureView, newSVpvs("WebGPU::Direct::TextureView"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "textureView", 11, (void **) &n->textureView, newSVpvs("WebGPU::Direct::TextureView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupEntry__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupEntry__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBindGroupEntry *n = (WGPUBindGroupEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBindGroupEntry) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BlendComponent	PREFIX = wgpu

SV *
operation(THIS, value = NO_INIT)
        WebGPU::Direct::BlendComponent THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBlendComponent *n = (WGPUBlendComponent *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "operation", 9,  &n->operation, newSVpvs("WebGPU::Direct::BlendOperation"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "operation", 9,  &n->operation, newSVpvs("WebGPU::Direct::BlendOperation"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
srcFactor(THIS, value = NO_INIT)
        WebGPU::Direct::BlendComponent THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBlendComponent *n = (WGPUBlendComponent *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "srcFactor", 9,  &n->srcFactor, newSVpvs("WebGPU::Direct::BlendFactor"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "srcFactor", 9,  &n->srcFactor, newSVpvs("WebGPU::Direct::BlendFactor"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
dstFactor(THIS, value = NO_INIT)
        WebGPU::Direct::BlendComponent THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBlendComponent *n = (WGPUBlendComponent *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "dstFactor", 9,  &n->dstFactor, newSVpvs("WebGPU::Direct::BlendFactor"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "dstFactor", 9,  &n->dstFactor, newSVpvs("WebGPU::Direct::BlendFactor"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BlendComponent__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BlendComponent__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBlendComponent *n = (WGPUBlendComponent *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBlendComponent) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BufferBindingLayout	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BufferBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
type(THIS, value = NO_INIT)
        WebGPU::Direct::BufferBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::BufferBindingType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::BufferBindingType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
hasDynamicOffset(THIS, value = NO_INIT)
        WebGPU::Direct::BufferBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "hasDynamicOffset", 16,  &n->hasDynamicOffset, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "hasDynamicOffset", 16,  &n->hasDynamicOffset, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
minBindingSize(THIS, value = NO_INIT)
        WebGPU::Direct::BufferBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "minBindingSize", 14,  &n->minBindingSize, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "minBindingSize", 14,  &n->minBindingSize, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BufferBindingLayout__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BufferBindingLayout__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBufferBindingLayout *n = (WGPUBufferBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBufferBindingLayout) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BufferDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BufferDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::BufferDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
usage(THIS, value = NO_INIT)
        WebGPU::Direct::BufferDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::BufferUsage"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::BufferUsage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
size(THIS, value = NO_INIT)
        WebGPU::Direct::BufferDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "size", 4,  &n->size, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mappedAtCreation(THIS, value = NO_INIT)
        WebGPU::Direct::BufferDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "mappedAtCreation", 16,  &n->mappedAtCreation, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "mappedAtCreation", 16,  &n->mappedAtCreation, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BufferDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BufferDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBufferDescriptor *n = (WGPUBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBufferDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Color	PREFIX = wgpu

SV *
r(THIS, value = NO_INIT)
        WebGPU::Direct::Color THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_double(aTHX_ h, "r", 1,  &n->r, NULL);

        if (items > 1)
        {
              _store_double(aTHX_ h, "r", 1,  &n->r, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
g(THIS, value = NO_INIT)
        WebGPU::Direct::Color THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_double(aTHX_ h, "g", 1,  &n->g, NULL);

        if (items > 1)
        {
              _store_double(aTHX_ h, "g", 1,  &n->g, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
b(THIS, value = NO_INIT)
        WebGPU::Direct::Color THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_double(aTHX_ h, "b", 1,  &n->b, NULL);

        if (items > 1)
        {
              _store_double(aTHX_ h, "b", 1,  &n->b, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
a(THIS, value = NO_INIT)
        WebGPU::Direct::Color THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_double(aTHX_ h, "a", 1,  &n->a, NULL);

        if (items > 1)
        {
              _store_double(aTHX_ h, "a", 1,  &n->a, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Color__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Color__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUColor *n = (WGPUColor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUColor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CommandBufferDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CommandBufferDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCommandBufferDescriptor *n = (WGPUCommandBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::CommandBufferDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCommandBufferDescriptor *n = (WGPUCommandBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CommandBufferDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CommandBufferDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCommandBufferDescriptor *n = (WGPUCommandBufferDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCommandBufferDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CommandEncoderDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CommandEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCommandEncoderDescriptor *n = (WGPUCommandEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::CommandEncoderDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCommandEncoderDescriptor *n = (WGPUCommandEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CommandEncoderDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CommandEncoderDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCommandEncoderDescriptor *n = (WGPUCommandEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCommandEncoderDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CompilationMessage	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
message(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "message", 7,  &n->message, sizeof(n->message), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "message", 7,  &n->message, sizeof(n->message), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
type(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::CompilationMessageType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::CompilationMessageType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
lineNum(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "lineNum", 7,  &n->lineNum, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "lineNum", 7,  &n->lineNum, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
linePos(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "linePos", 7,  &n->linePos, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "linePos", 7,  &n->linePos, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
offset(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
length(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationMessage THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "length", 6,  &n->length, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "length", 6,  &n->length, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CompilationMessage__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CompilationMessage__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCompilationMessage *n = (WGPUCompilationMessage *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCompilationMessage) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ComputePassTimestampWrites	PREFIX = wgpu

SV *
querySet(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePassTimestampWrites THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePassTimestampWrites *n = (WGPUComputePassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
beginningOfPassWriteIndex(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePassTimestampWrites THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePassTimestampWrites *n = (WGPUComputePassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
endOfPassWriteIndex(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePassTimestampWrites THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePassTimestampWrites *n = (WGPUComputePassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ComputePassTimestampWrites__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ComputePassTimestampWrites__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUComputePassTimestampWrites *n = (WGPUComputePassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUComputePassTimestampWrites) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ConstantEntry	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::ConstantEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUConstantEntry *n = (WGPUConstantEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
key(THIS, value = NO_INIT)
        WebGPU::Direct::ConstantEntry THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUConstantEntry *n = (WGPUConstantEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "key", 3,  &n->key, sizeof(n->key), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "key", 3,  &n->key, sizeof(n->key), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
value(THIS, value = NO_INIT)
        WebGPU::Direct::ConstantEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUConstantEntry *n = (WGPUConstantEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_double(aTHX_ h, "value", 5,  &n->value, NULL);

        if (items > 1)
        {
              _store_double(aTHX_ h, "value", 5,  &n->value, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ConstantEntry__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ConstantEntry__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUConstantEntry *n = (WGPUConstantEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUConstantEntry) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Extent3D	PREFIX = wgpu

SV *
width(THIS, value = NO_INIT)
        WebGPU::Direct::Extent3D THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUExtent3D *n = (WGPUExtent3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
height(THIS, value = NO_INIT)
        WebGPU::Direct::Extent3D THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUExtent3D *n = (WGPUExtent3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthOrArrayLayers(THIS, value = NO_INIT)
        WebGPU::Direct::Extent3D THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUExtent3D *n = (WGPUExtent3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "depthOrArrayLayers", 18,  &n->depthOrArrayLayers, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "depthOrArrayLayers", 18,  &n->depthOrArrayLayers, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Extent3D__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Extent3D__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUExtent3D *n = (WGPUExtent3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUExtent3D) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Future	PREFIX = wgpu

SV *
id(THIS, value = NO_INIT)
        WebGPU::Direct::Future THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFuture *n = (WGPUFuture *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "id", 2,  &n->id, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "id", 2,  &n->id, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Future__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Future__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUFuture *n = (WGPUFuture *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUFuture) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::InstanceCapabilities	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::InstanceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUInstanceCapabilities *n = (WGPUInstanceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
timedWaitAnyEnable(THIS, value = NO_INIT)
        WebGPU::Direct::InstanceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUInstanceCapabilities *n = (WGPUInstanceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "timedWaitAnyEnable", 18,  &n->timedWaitAnyEnable, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "timedWaitAnyEnable", 18,  &n->timedWaitAnyEnable, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
timedWaitAnyMaxCount(THIS, value = NO_INIT)
        WebGPU::Direct::InstanceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUInstanceCapabilities *n = (WGPUInstanceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "timedWaitAnyMaxCount", 20,  &n->timedWaitAnyMaxCount, NULL);

        if (items > 1)
        {
              _store_size_t(aTHX_ h, "timedWaitAnyMaxCount", 20,  &n->timedWaitAnyMaxCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__InstanceCapabilities__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__InstanceCapabilities__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUInstanceCapabilities *n = (WGPUInstanceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUInstanceCapabilities) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Limits	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxTextureDimension1D(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxTextureDimension1D", 21,  &n->maxTextureDimension1D, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxTextureDimension1D", 21,  &n->maxTextureDimension1D, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxTextureDimension2D(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxTextureDimension2D", 21,  &n->maxTextureDimension2D, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxTextureDimension2D", 21,  &n->maxTextureDimension2D, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxTextureDimension3D(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxTextureDimension3D", 21,  &n->maxTextureDimension3D, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxTextureDimension3D", 21,  &n->maxTextureDimension3D, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxTextureArrayLayers(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxTextureArrayLayers", 21,  &n->maxTextureArrayLayers, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxTextureArrayLayers", 21,  &n->maxTextureArrayLayers, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxBindGroups(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxBindGroups", 13,  &n->maxBindGroups, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxBindGroups", 13,  &n->maxBindGroups, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxBindGroupsPlusVertexBuffers(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxBindGroupsPlusVertexBuffers", 30,  &n->maxBindGroupsPlusVertexBuffers, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxBindGroupsPlusVertexBuffers", 30,  &n->maxBindGroupsPlusVertexBuffers, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxBindingsPerBindGroup(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxBindingsPerBindGroup", 23,  &n->maxBindingsPerBindGroup, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxBindingsPerBindGroup", 23,  &n->maxBindingsPerBindGroup, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxDynamicUniformBuffersPerPipelineLayout(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxDynamicUniformBuffersPerPipelineLayout", 41,  &n->maxDynamicUniformBuffersPerPipelineLayout, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxDynamicUniformBuffersPerPipelineLayout", 41,  &n->maxDynamicUniformBuffersPerPipelineLayout, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxDynamicStorageBuffersPerPipelineLayout(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxDynamicStorageBuffersPerPipelineLayout", 41,  &n->maxDynamicStorageBuffersPerPipelineLayout, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxDynamicStorageBuffersPerPipelineLayout", 41,  &n->maxDynamicStorageBuffersPerPipelineLayout, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxSampledTexturesPerShaderStage(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxSampledTexturesPerShaderStage", 32,  &n->maxSampledTexturesPerShaderStage, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxSampledTexturesPerShaderStage", 32,  &n->maxSampledTexturesPerShaderStage, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxSamplersPerShaderStage(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxSamplersPerShaderStage", 25,  &n->maxSamplersPerShaderStage, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxSamplersPerShaderStage", 25,  &n->maxSamplersPerShaderStage, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxStorageBuffersPerShaderStage(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxStorageBuffersPerShaderStage", 31,  &n->maxStorageBuffersPerShaderStage, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxStorageBuffersPerShaderStage", 31,  &n->maxStorageBuffersPerShaderStage, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxStorageTexturesPerShaderStage(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxStorageTexturesPerShaderStage", 32,  &n->maxStorageTexturesPerShaderStage, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxStorageTexturesPerShaderStage", 32,  &n->maxStorageTexturesPerShaderStage, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxUniformBuffersPerShaderStage(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxUniformBuffersPerShaderStage", 31,  &n->maxUniformBuffersPerShaderStage, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxUniformBuffersPerShaderStage", 31,  &n->maxUniformBuffersPerShaderStage, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxUniformBufferBindingSize(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "maxUniformBufferBindingSize", 27,  &n->maxUniformBufferBindingSize, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "maxUniformBufferBindingSize", 27,  &n->maxUniformBufferBindingSize, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxStorageBufferBindingSize(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "maxStorageBufferBindingSize", 27,  &n->maxStorageBufferBindingSize, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "maxStorageBufferBindingSize", 27,  &n->maxStorageBufferBindingSize, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
minUniformBufferOffsetAlignment(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "minUniformBufferOffsetAlignment", 31,  &n->minUniformBufferOffsetAlignment, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "minUniformBufferOffsetAlignment", 31,  &n->minUniformBufferOffsetAlignment, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
minStorageBufferOffsetAlignment(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "minStorageBufferOffsetAlignment", 31,  &n->minStorageBufferOffsetAlignment, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "minStorageBufferOffsetAlignment", 31,  &n->minStorageBufferOffsetAlignment, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxVertexBuffers(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxVertexBuffers", 16,  &n->maxVertexBuffers, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxVertexBuffers", 16,  &n->maxVertexBuffers, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxBufferSize(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "maxBufferSize", 13,  &n->maxBufferSize, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "maxBufferSize", 13,  &n->maxBufferSize, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxVertexAttributes(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxVertexAttributes", 19,  &n->maxVertexAttributes, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxVertexAttributes", 19,  &n->maxVertexAttributes, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxVertexBufferArrayStride(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxVertexBufferArrayStride", 26,  &n->maxVertexBufferArrayStride, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxVertexBufferArrayStride", 26,  &n->maxVertexBufferArrayStride, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxInterStageShaderVariables(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxInterStageShaderVariables", 28,  &n->maxInterStageShaderVariables, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxInterStageShaderVariables", 28,  &n->maxInterStageShaderVariables, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxColorAttachments(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxColorAttachments", 19,  &n->maxColorAttachments, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxColorAttachments", 19,  &n->maxColorAttachments, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxColorAttachmentBytesPerSample(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxColorAttachmentBytesPerSample", 32,  &n->maxColorAttachmentBytesPerSample, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxColorAttachmentBytesPerSample", 32,  &n->maxColorAttachmentBytesPerSample, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxComputeWorkgroupStorageSize(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxComputeWorkgroupStorageSize", 30,  &n->maxComputeWorkgroupStorageSize, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxComputeWorkgroupStorageSize", 30,  &n->maxComputeWorkgroupStorageSize, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxComputeInvocationsPerWorkgroup(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxComputeInvocationsPerWorkgroup", 33,  &n->maxComputeInvocationsPerWorkgroup, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxComputeInvocationsPerWorkgroup", 33,  &n->maxComputeInvocationsPerWorkgroup, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxComputeWorkgroupSizeX(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeX", 24,  &n->maxComputeWorkgroupSizeX, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeX", 24,  &n->maxComputeWorkgroupSizeX, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxComputeWorkgroupSizeY(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeY", 24,  &n->maxComputeWorkgroupSizeY, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeY", 24,  &n->maxComputeWorkgroupSizeY, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxComputeWorkgroupSizeZ(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeZ", 24,  &n->maxComputeWorkgroupSizeZ, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxComputeWorkgroupSizeZ", 24,  &n->maxComputeWorkgroupSizeZ, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxComputeWorkgroupsPerDimension(THIS, value = NO_INIT)
        WebGPU::Direct::Limits THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "maxComputeWorkgroupsPerDimension", 32,  &n->maxComputeWorkgroupsPerDimension, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "maxComputeWorkgroupsPerDimension", 32,  &n->maxComputeWorkgroupsPerDimension, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Limits__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Limits__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPULimits *n = (WGPULimits *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPULimits) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::MultisampleState	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::MultisampleState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
count(THIS, value = NO_INIT)
        WebGPU::Direct::MultisampleState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mask(THIS, value = NO_INIT)
        WebGPU::Direct::MultisampleState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "mask", 4,  &n->mask, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "mask", 4,  &n->mask, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
alphaToCoverageEnabled(THIS, value = NO_INIT)
        WebGPU::Direct::MultisampleState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "alphaToCoverageEnabled", 22,  &n->alphaToCoverageEnabled, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "alphaToCoverageEnabled", 22,  &n->alphaToCoverageEnabled, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__MultisampleState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__MultisampleState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUMultisampleState *n = (WGPUMultisampleState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUMultisampleState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::Origin3D	PREFIX = wgpu

SV *
x(THIS, value = NO_INIT)
        WebGPU::Direct::Origin3D THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUOrigin3D *n = (WGPUOrigin3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "x", 1,  &n->x, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "x", 1,  &n->x, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
y(THIS, value = NO_INIT)
        WebGPU::Direct::Origin3D THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUOrigin3D *n = (WGPUOrigin3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "y", 1,  &n->y, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "y", 1,  &n->y, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
z(THIS, value = NO_INIT)
        WebGPU::Direct::Origin3D THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUOrigin3D *n = (WGPUOrigin3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "z", 1,  &n->z, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "z", 1,  &n->z, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Origin3D__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__Origin3D__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUOrigin3D *n = (WGPUOrigin3D *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUOrigin3D) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::PipelineLayoutDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::PipelineLayoutDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::PipelineLayoutDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
bindGroupLayoutCount(THIS, value = NO_INIT)
        WebGPU::Direct::PipelineLayoutDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "bindGroupLayoutCount", 20,  &n->bindGroupLayoutCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
bindGroupLayouts(THIS, value = NO_INIT)
        WebGPU::Direct::PipelineLayoutDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "bindGroupLayouts", 16, (void **) &n->bindGroupLayouts, &n->bindGroupLayoutCount, sizeof(*n->bindGroupLayouts), newSVpvs("WebGPU::Direct::BindGroupLayout"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "bindGroupLayouts", 16, (void **) &n->bindGroupLayouts, &n->bindGroupLayoutCount, sizeof(*n->bindGroupLayouts), newSVpvs("WebGPU::Direct::BindGroupLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__PipelineLayoutDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__PipelineLayoutDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUPipelineLayoutDescriptor *n = (WGPUPipelineLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUPipelineLayoutDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::PrimitiveState	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::PrimitiveState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
topology(THIS, value = NO_INIT)
        WebGPU::Direct::PrimitiveState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "topology", 8,  &n->topology, newSVpvs("WebGPU::Direct::PrimitiveTopology"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "topology", 8,  &n->topology, newSVpvs("WebGPU::Direct::PrimitiveTopology"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stripIndexFormat(THIS, value = NO_INIT)
        WebGPU::Direct::PrimitiveState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "stripIndexFormat", 16,  &n->stripIndexFormat, newSVpvs("WebGPU::Direct::IndexFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "stripIndexFormat", 16,  &n->stripIndexFormat, newSVpvs("WebGPU::Direct::IndexFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
frontFace(THIS, value = NO_INIT)
        WebGPU::Direct::PrimitiveState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "frontFace", 9,  &n->frontFace, newSVpvs("WebGPU::Direct::FrontFace"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "frontFace", 9,  &n->frontFace, newSVpvs("WebGPU::Direct::FrontFace"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
cullMode(THIS, value = NO_INIT)
        WebGPU::Direct::PrimitiveState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "cullMode", 8,  &n->cullMode, newSVpvs("WebGPU::Direct::CullMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "cullMode", 8,  &n->cullMode, newSVpvs("WebGPU::Direct::CullMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
unclippedDepth(THIS, value = NO_INIT)
        WebGPU::Direct::PrimitiveState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "unclippedDepth", 14,  &n->unclippedDepth, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "unclippedDepth", 14,  &n->unclippedDepth, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__PrimitiveState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__PrimitiveState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUPrimitiveState *n = (WGPUPrimitiveState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUPrimitiveState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::QuerySetDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::QuerySetDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::QuerySetDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
type(THIS, value = NO_INIT)
        WebGPU::Direct::QuerySetDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::QueryType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::QueryType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
count(THIS, value = NO_INIT)
        WebGPU::Direct::QuerySetDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "count", 5,  &n->count, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__QuerySetDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__QuerySetDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUQuerySetDescriptor *n = (WGPUQuerySetDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUQuerySetDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::QueueDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::QueueDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQueueDescriptor *n = (WGPUQueueDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::QueueDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUQueueDescriptor *n = (WGPUQueueDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__QueueDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__QueueDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUQueueDescriptor *n = (WGPUQueueDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUQueueDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderBundleDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleDescriptor *n = (WGPURenderBundleDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleDescriptor *n = (WGPURenderBundleDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderBundleDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderBundleDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderBundleDescriptor *n = (WGPURenderBundleDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderBundleDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderBundleEncoderDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
colorFormatCount(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "colorFormatCount", 16,  &n->colorFormatCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
colorFormats(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "colorFormats", 12, (void **) &n->colorFormats, &n->colorFormatCount, sizeof(*n->colorFormats), newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "colorFormats", 12, (void **) &n->colorFormats, &n->colorFormatCount, sizeof(*n->colorFormats), newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthStencilFormat(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "depthStencilFormat", 18,  &n->depthStencilFormat, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "depthStencilFormat", 18,  &n->depthStencilFormat, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sampleCount(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthReadOnly(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilReadOnly(THIS, value = NO_INIT)
        WebGPU::Direct::RenderBundleEncoderDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderBundleEncoderDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderBundleEncoderDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderBundleEncoderDescriptor *n = (WGPURenderBundleEncoderDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderBundleEncoderDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPassDepthStencilAttachment	PREFIX = wgpu

SV *
view(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthLoadOp(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "depthLoadOp", 11,  &n->depthLoadOp, newSVpvs("WebGPU::Direct::LoadOp"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "depthLoadOp", 11,  &n->depthLoadOp, newSVpvs("WebGPU::Direct::LoadOp"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthStoreOp(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "depthStoreOp", 12,  &n->depthStoreOp, newSVpvs("WebGPU::Direct::StoreOp"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "depthStoreOp", 12,  &n->depthStoreOp, newSVpvs("WebGPU::Direct::StoreOp"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthClearValue(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_float(aTHX_ h, "depthClearValue", 15,  &n->depthClearValue, NULL);

        if (items > 1)
        {
              _store_float(aTHX_ h, "depthClearValue", 15,  &n->depthClearValue, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthReadOnly(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "depthReadOnly", 13,  &n->depthReadOnly, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilLoadOp(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "stencilLoadOp", 13,  &n->stencilLoadOp, newSVpvs("WebGPU::Direct::LoadOp"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "stencilLoadOp", 13,  &n->stencilLoadOp, newSVpvs("WebGPU::Direct::LoadOp"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilStoreOp(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "stencilStoreOp", 14,  &n->stencilStoreOp, newSVpvs("WebGPU::Direct::StoreOp"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "stencilStoreOp", 14,  &n->stencilStoreOp, newSVpvs("WebGPU::Direct::StoreOp"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilClearValue(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "stencilClearValue", 17,  &n->stencilClearValue, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "stencilClearValue", 17,  &n->stencilClearValue, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilReadOnly(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDepthStencilAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "stencilReadOnly", 15,  &n->stencilReadOnly, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassDepthStencilAttachment__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassDepthStencilAttachment__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderPassDepthStencilAttachment *n = (WGPURenderPassDepthStencilAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderPassDepthStencilAttachment) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPassMaxDrawCount	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassMaxDrawCount THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassMaxDrawCount *n = (WGPURenderPassMaxDrawCount *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxDrawCount(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassMaxDrawCount THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassMaxDrawCount *n = (WGPURenderPassMaxDrawCount *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "maxDrawCount", 12,  &n->maxDrawCount, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "maxDrawCount", 12,  &n->maxDrawCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassMaxDrawCount__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassMaxDrawCount__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderPassMaxDrawCount *n = (WGPURenderPassMaxDrawCount *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderPassMaxDrawCount) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPassTimestampWrites	PREFIX = wgpu

SV *
querySet(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassTimestampWrites THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassTimestampWrites *n = (WGPURenderPassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "querySet", 8, (void **) &n->querySet, newSVpvs("WebGPU::Direct::QuerySet"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
beginningOfPassWriteIndex(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassTimestampWrites THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassTimestampWrites *n = (WGPURenderPassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "beginningOfPassWriteIndex", 25,  &n->beginningOfPassWriteIndex, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
endOfPassWriteIndex(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassTimestampWrites THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassTimestampWrites *n = (WGPURenderPassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "endOfPassWriteIndex", 19,  &n->endOfPassWriteIndex, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassTimestampWrites__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassTimestampWrites__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderPassTimestampWrites *n = (WGPURenderPassTimestampWrites *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderPassTimestampWrites) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RequestAdapterOptions	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterOptions THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
featureLevel(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterOptions THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "featureLevel", 12,  &n->featureLevel, newSVpvs("WebGPU::Direct::FeatureLevel"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "featureLevel", 12,  &n->featureLevel, newSVpvs("WebGPU::Direct::FeatureLevel"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
powerPreference(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterOptions THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "powerPreference", 15,  &n->powerPreference, newSVpvs("WebGPU::Direct::PowerPreference"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "powerPreference", 15,  &n->powerPreference, newSVpvs("WebGPU::Direct::PowerPreference"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
forceFallbackAdapter(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterOptions THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "forceFallbackAdapter", 20,  &n->forceFallbackAdapter, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "forceFallbackAdapter", 20,  &n->forceFallbackAdapter, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
backendType(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterOptions THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "backendType", 11,  &n->backendType, newSVpvs("WebGPU::Direct::BackendType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
compatibleSurface(THIS, value = NO_INIT)
        WebGPU::Direct::RequestAdapterOptions THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "compatibleSurface", 17, (void **) &n->compatibleSurface, newSVpvs("WebGPU::Direct::Surface"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "compatibleSurface", 17, (void **) &n->compatibleSurface, newSVpvs("WebGPU::Direct::Surface"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RequestAdapterOptions__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RequestAdapterOptions__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURequestAdapterOptions *n = (WGPURequestAdapterOptions *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURequestAdapterOptions) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SamplerBindingLayout	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerBindingLayout *n = (WGPUSamplerBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
type(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerBindingLayout *n = (WGPUSamplerBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::SamplerBindingType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "type", 4,  &n->type, newSVpvs("WebGPU::Direct::SamplerBindingType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SamplerBindingLayout__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SamplerBindingLayout__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSamplerBindingLayout *n = (WGPUSamplerBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSamplerBindingLayout) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SamplerDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
addressModeU(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "addressModeU", 12,  &n->addressModeU, newSVpvs("WebGPU::Direct::AddressMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "addressModeU", 12,  &n->addressModeU, newSVpvs("WebGPU::Direct::AddressMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
addressModeV(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "addressModeV", 12,  &n->addressModeV, newSVpvs("WebGPU::Direct::AddressMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "addressModeV", 12,  &n->addressModeV, newSVpvs("WebGPU::Direct::AddressMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
addressModeW(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "addressModeW", 12,  &n->addressModeW, newSVpvs("WebGPU::Direct::AddressMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "addressModeW", 12,  &n->addressModeW, newSVpvs("WebGPU::Direct::AddressMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
magFilter(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "magFilter", 9,  &n->magFilter, newSVpvs("WebGPU::Direct::FilterMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "magFilter", 9,  &n->magFilter, newSVpvs("WebGPU::Direct::FilterMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
minFilter(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "minFilter", 9,  &n->minFilter, newSVpvs("WebGPU::Direct::FilterMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "minFilter", 9,  &n->minFilter, newSVpvs("WebGPU::Direct::FilterMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mipmapFilter(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "mipmapFilter", 12,  &n->mipmapFilter, newSVpvs("WebGPU::Direct::MipmapFilterMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "mipmapFilter", 12,  &n->mipmapFilter, newSVpvs("WebGPU::Direct::MipmapFilterMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
lodMinClamp(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_float(aTHX_ h, "lodMinClamp", 11,  &n->lodMinClamp, NULL);

        if (items > 1)
        {
              _store_float(aTHX_ h, "lodMinClamp", 11,  &n->lodMinClamp, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
lodMaxClamp(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_float(aTHX_ h, "lodMaxClamp", 11,  &n->lodMaxClamp, NULL);

        if (items > 1)
        {
              _store_float(aTHX_ h, "lodMaxClamp", 11,  &n->lodMaxClamp, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
compare(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
maxAnisotropy(THIS, value = NO_INIT)
        WebGPU::Direct::SamplerDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint16_t(aTHX_ h, "maxAnisotropy", 13,  &n->maxAnisotropy, NULL);

        if (items > 1)
        {
              _store_uint16_t(aTHX_ h, "maxAnisotropy", 13,  &n->maxAnisotropy, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SamplerDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SamplerDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSamplerDescriptor *n = (WGPUSamplerDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSamplerDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ShaderModuleDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderModuleDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderModuleDescriptor *n = (WGPUShaderModuleDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderModuleDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderModuleDescriptor *n = (WGPUShaderModuleDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ShaderModuleDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ShaderModuleDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUShaderModuleDescriptor *n = (WGPUShaderModuleDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUShaderModuleDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ShaderSourceSPIRV	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderSourceSPIRV THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderSourceSPIRV *n = (WGPUShaderSourceSPIRV *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
codeSize(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderSourceSPIRV THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderSourceSPIRV *n = (WGPUShaderSourceSPIRV *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "codeSize", 8,  &n->codeSize, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "codeSize", 8,  &n->codeSize, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
code(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderSourceSPIRV THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderSourceSPIRV *n = (WGPUShaderSourceSPIRV *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "code" is a ptr type uint32_t, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "code", 4,  &n->code, NULL);

        if (items > 1)
        {
              // "code" is a ptr type uint32_t, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "code", 4,  &n->code, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ShaderSourceSPIRV__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ShaderSourceSPIRV__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUShaderSourceSPIRV *n = (WGPUShaderSourceSPIRV *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUShaderSourceSPIRV) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ShaderSourceWGSL	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderSourceWGSL THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderSourceWGSL *n = (WGPUShaderSourceWGSL *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
code(THIS, value = NO_INIT)
        WebGPU::Direct::ShaderSourceWGSL THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUShaderSourceWGSL *n = (WGPUShaderSourceWGSL *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "code", 4,  &n->code, sizeof(n->code), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "code", 4,  &n->code, sizeof(n->code), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ShaderSourceWGSL__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ShaderSourceWGSL__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUShaderSourceWGSL *n = (WGPUShaderSourceWGSL *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUShaderSourceWGSL) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::StencilFaceState	PREFIX = wgpu

SV *
compare(THIS, value = NO_INIT)
        WebGPU::Direct::StencilFaceState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "compare", 7,  &n->compare, newSVpvs("WebGPU::Direct::CompareFunction"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
failOp(THIS, value = NO_INIT)
        WebGPU::Direct::StencilFaceState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "failOp", 6,  &n->failOp, newSVpvs("WebGPU::Direct::StencilOperation"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "failOp", 6,  &n->failOp, newSVpvs("WebGPU::Direct::StencilOperation"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthFailOp(THIS, value = NO_INIT)
        WebGPU::Direct::StencilFaceState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "depthFailOp", 11,  &n->depthFailOp, newSVpvs("WebGPU::Direct::StencilOperation"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "depthFailOp", 11,  &n->depthFailOp, newSVpvs("WebGPU::Direct::StencilOperation"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
passOp(THIS, value = NO_INIT)
        WebGPU::Direct::StencilFaceState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "passOp", 6,  &n->passOp, newSVpvs("WebGPU::Direct::StencilOperation"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "passOp", 6,  &n->passOp, newSVpvs("WebGPU::Direct::StencilOperation"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__StencilFaceState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__StencilFaceState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUStencilFaceState *n = (WGPUStencilFaceState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUStencilFaceState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::StorageTextureBindingLayout	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::StorageTextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
access(THIS, value = NO_INIT)
        WebGPU::Direct::StorageTextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "access", 6,  &n->access, newSVpvs("WebGPU::Direct::StorageTextureAccess"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "access", 6,  &n->access, newSVpvs("WebGPU::Direct::StorageTextureAccess"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::StorageTextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
viewDimension(THIS, value = NO_INIT)
        WebGPU::Direct::StorageTextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__StorageTextureBindingLayout__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__StorageTextureBindingLayout__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUStorageTextureBindingLayout *n = (WGPUStorageTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUStorageTextureBindingLayout) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SupportedFeatures	PREFIX = wgpuSupportedFeatures

SV *
featureCount(THIS, value = NO_INIT)
        WebGPU::Direct::SupportedFeatures THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSupportedFeatures *n = (WGPUSupportedFeatures *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "featureCount", 12,  &n->featureCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
features(THIS, value = NO_INIT)
        WebGPU::Direct::SupportedFeatures THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSupportedFeatures *n = (WGPUSupportedFeatures *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::FeatureName"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::FeatureName"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SupportedFeatures__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SupportedFeatures__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSupportedFeatures *n = (WGPUSupportedFeatures *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSupportedFeatures) );
    OUTPUT:
        RETVAL


void 
wgpuSupportedFeaturesfreeMembers(supportedFeatures)
        WGPUSupportedFeatures supportedFeatures
    CODE:
      wgpuSupportedFeaturesFreeMembers(supportedFeatures);
      {
        SV *u = ST(0);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SupportedWGSLLanguageFeatures	PREFIX = wgpuSupportedWGSLLanguageFeatures

SV *
featureCount(THIS, value = NO_INIT)
        WebGPU::Direct::SupportedWGSLLanguageFeatures THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSupportedWGSLLanguageFeatures *n = (WGPUSupportedWGSLLanguageFeatures *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "featureCount", 12,  &n->featureCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
features(THIS, value = NO_INIT)
        WebGPU::Direct::SupportedWGSLLanguageFeatures THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSupportedWGSLLanguageFeatures *n = (WGPUSupportedWGSLLanguageFeatures *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::WGSLLanguageFeatureName"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "features", 8, (void **) &n->features, &n->featureCount, sizeof(*n->features), newSVpvs("WebGPU::Direct::WGSLLanguageFeatureName"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SupportedWGSLLanguageFeatures__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SupportedWGSLLanguageFeatures__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSupportedWGSLLanguageFeatures *n = (WGPUSupportedWGSLLanguageFeatures *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSupportedWGSLLanguageFeatures) );
    OUTPUT:
        RETVAL


void 
wgpuSupportedWGSLLanguageFeaturesfreeMembers(supportedWGSLLanguageFeatures)
        WGPUSupportedWGSLLanguageFeatures supportedWGSLLanguageFeatures
    CODE:
      wgpuSupportedWGSLLanguageFeaturesFreeMembers(supportedWGSLLanguageFeatures);
      {
        SV *u = ST(0);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceCapabilities	PREFIX = wgpuSurfaceCapabilities

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
usages(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "usages", 6,  &n->usages, newSVpvs("WebGPU::Direct::TextureUsage"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "usages", 6,  &n->usages, newSVpvs("WebGPU::Direct::TextureUsage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
formatCount(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "formatCount", 11,  &n->formatCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
formats(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "formats", 7, (void **) &n->formats, &n->formatCount, sizeof(*n->formats), newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "formats", 7, (void **) &n->formats, &n->formatCount, sizeof(*n->formats), newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
presentModeCount(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "presentModeCount", 16,  &n->presentModeCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
presentModes(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "presentModes", 12, (void **) &n->presentModes, &n->presentModeCount, sizeof(*n->presentModes), newSVpvs("WebGPU::Direct::PresentMode"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "presentModes", 12, (void **) &n->presentModes, &n->presentModeCount, sizeof(*n->presentModes), newSVpvs("WebGPU::Direct::PresentMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
alphaModeCount(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "alphaModeCount", 14,  &n->alphaModeCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
alphaModes(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceCapabilities THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "alphaModes", 10, (void **) &n->alphaModes, &n->alphaModeCount, sizeof(*n->alphaModes), newSVpvs("WebGPU::Direct::CompositeAlphaMode"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "alphaModes", 10, (void **) &n->alphaModes, &n->alphaModeCount, sizeof(*n->alphaModes), newSVpvs("WebGPU::Direct::CompositeAlphaMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceCapabilities__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceCapabilities__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceCapabilities *n = (WGPUSurfaceCapabilities *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceCapabilities) );
    OUTPUT:
        RETVAL


void 
wgpuSurfaceCapabilitiesfreeMembers(surfaceCapabilities)
        WGPUSurfaceCapabilities surfaceCapabilities
    CODE:
      wgpuSurfaceCapabilitiesFreeMembers(surfaceCapabilities);
      {
        SV *u = ST(0);
        if ( sv_isobject(u) ) { _unpack(u); }
      }


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceConfiguration	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
device(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "device", 6, (void **) &n->device, newSVpvs("WebGPU::Direct::Device"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "device", 6, (void **) &n->device, newSVpvs("WebGPU::Direct::Device"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
usage(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
width(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "width", 5,  &n->width, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
height(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "height", 6,  &n->height, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
viewFormatCount(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "viewFormatCount", 15,  &n->viewFormatCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
viewFormats(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
alphaMode(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "alphaMode", 9,  &n->alphaMode, newSVpvs("WebGPU::Direct::CompositeAlphaMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "alphaMode", 9,  &n->alphaMode, newSVpvs("WebGPU::Direct::CompositeAlphaMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
presentMode(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceConfiguration THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "presentMode", 11,  &n->presentMode, newSVpvs("WebGPU::Direct::PresentMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "presentMode", 11,  &n->presentMode, newSVpvs("WebGPU::Direct::PresentMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceConfiguration__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceConfiguration__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceConfiguration *n = (WGPUSurfaceConfiguration *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceConfiguration) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceDescriptor *n = (WGPUSurfaceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceDescriptor *n = (WGPUSurfaceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceDescriptor *n = (WGPUSurfaceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceSourceAndroidNativeWindow	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceAndroidNativeWindow THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceAndroidNativeWindow *n = (WGPUSurfaceSourceAndroidNativeWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
window(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceAndroidNativeWindow THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceAndroidNativeWindow *n = (WGPUSurfaceSourceAndroidNativeWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "window" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "window", 6,  &n->window, NULL);

        if (items > 1)
        {
              // "window" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "window", 6,  &n->window, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceAndroidNativeWindow__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceAndroidNativeWindow__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceSourceAndroidNativeWindow *n = (WGPUSurfaceSourceAndroidNativeWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceSourceAndroidNativeWindow) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceSourceMetalLayer	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceMetalLayer THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceMetalLayer *n = (WGPUSurfaceSourceMetalLayer *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
layer(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceMetalLayer THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceMetalLayer *n = (WGPUSurfaceSourceMetalLayer *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "layer" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "layer", 5,  &n->layer, NULL);

        if (items > 1)
        {
              // "layer" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "layer", 5,  &n->layer, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceMetalLayer__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceMetalLayer__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceSourceMetalLayer *n = (WGPUSurfaceSourceMetalLayer *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceSourceMetalLayer) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceSourceWaylandSurface	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceWaylandSurface THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceWaylandSurface *n = (WGPUSurfaceSourceWaylandSurface *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
display(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceWaylandSurface THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceWaylandSurface *n = (WGPUSurfaceSourceWaylandSurface *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "display" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "display", 7,  &n->display, NULL);

        if (items > 1)
        {
              // "display" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "display", 7,  &n->display, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
surface(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceWaylandSurface THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceWaylandSurface *n = (WGPUSurfaceSourceWaylandSurface *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "surface" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "surface", 7,  &n->surface, NULL);

        if (items > 1)
        {
              // "surface" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "surface", 7,  &n->surface, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceWaylandSurface__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceWaylandSurface__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceSourceWaylandSurface *n = (WGPUSurfaceSourceWaylandSurface *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceSourceWaylandSurface) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceSourceWindowsHWND	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceWindowsHWND THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceWindowsHWND *n = (WGPUSurfaceSourceWindowsHWND *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
hinstance(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceWindowsHWND THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceWindowsHWND *n = (WGPUSurfaceSourceWindowsHWND *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "hinstance" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "hinstance", 9,  &n->hinstance, NULL);

        if (items > 1)
        {
              // "hinstance" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "hinstance", 9,  &n->hinstance, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
hwnd(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceWindowsHWND THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceWindowsHWND *n = (WGPUSurfaceSourceWindowsHWND *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "hwnd" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "hwnd", 4,  &n->hwnd, NULL);

        if (items > 1)
        {
              // "hwnd" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "hwnd", 4,  &n->hwnd, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceWindowsHWND__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceWindowsHWND__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceSourceWindowsHWND *n = (WGPUSurfaceSourceWindowsHWND *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceSourceWindowsHWND) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceSourceXCBWindow	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceXCBWindow THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceXCBWindow *n = (WGPUSurfaceSourceXCBWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
connection(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceXCBWindow THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceXCBWindow *n = (WGPUSurfaceSourceXCBWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "connection" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "connection", 10,  &n->connection, NULL);

        if (items > 1)
        {
              // "connection" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "connection", 10,  &n->connection, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
window(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceXCBWindow THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceXCBWindow *n = (WGPUSurfaceSourceXCBWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "window", 6,  &n->window, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "window", 6,  &n->window, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceXCBWindow__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceXCBWindow__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceSourceXCBWindow *n = (WGPUSurfaceSourceXCBWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceSourceXCBWindow) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceSourceXlibWindow	PREFIX = wgpu

SV *
chain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceXlibWindow THIS
        WebGPU::Direct::ChainedStruct value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceXlibWindow *n = (WGPUSurfaceSourceXlibWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "chain", 5,  &n->chain, sizeof(n->chain), newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
display(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceXlibWindow THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceXlibWindow *n = (WGPUSurfaceSourceXlibWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   // "display" is a ptr type void, and that's not quite right yet, using opaque
  _find_void(aTHX_ h, "display", 7,  &n->display, NULL);

        if (items > 1)
        {
              // "display" is a ptr type void, and that's not quite right yet, using opaque
  _store_void(aTHX_ h, "display", 7,  &n->display, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
window(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceSourceXlibWindow THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceSourceXlibWindow *n = (WGPUSurfaceSourceXlibWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "window", 6,  &n->window, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "window", 6,  &n->window, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceXlibWindow__pack( THIS );
        WebGPU__Direct__ChainedStruct__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceSourceXlibWindow__unpack( THIS );
        WebGPU__Direct__ChainedStruct__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceSourceXlibWindow *n = (WGPUSurfaceSourceXlibWindow *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceSourceXlibWindow) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::SurfaceTexture	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceTexture THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceTexture *n = (WGPUSurfaceTexture *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStructOut"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
texture(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceTexture THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceTexture *n = (WGPUSurfaceTexture *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
status(THIS, value = NO_INIT)
        WebGPU::Direct::SurfaceTexture THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUSurfaceTexture *n = (WGPUSurfaceTexture *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "status", 6,  &n->status, newSVpvs("WebGPU::Direct::SurfaceGetCurrentTextureStatus"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "status", 6,  &n->status, newSVpvs("WebGPU::Direct::SurfaceGetCurrentTextureStatus"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceTexture__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__SurfaceTexture__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUSurfaceTexture *n = (WGPUSurfaceTexture *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUSurfaceTexture) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TexelCopyBufferLayout	PREFIX = wgpu

SV *
offset(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyBufferLayout *n = (WGPUTexelCopyBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
bytesPerRow(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyBufferLayout *n = (WGPUTexelCopyBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "bytesPerRow", 11,  &n->bytesPerRow, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "bytesPerRow", 11,  &n->bytesPerRow, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
rowsPerImage(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyBufferLayout *n = (WGPUTexelCopyBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "rowsPerImage", 12,  &n->rowsPerImage, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "rowsPerImage", 12,  &n->rowsPerImage, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TexelCopyBufferLayout__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TexelCopyBufferLayout__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUTexelCopyBufferLayout *n = (WGPUTexelCopyBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUTexelCopyBufferLayout) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TextureBindingLayout	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::TextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sampleType(THIS, value = NO_INIT)
        WebGPU::Direct::TextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "sampleType", 10,  &n->sampleType, newSVpvs("WebGPU::Direct::TextureSampleType"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "sampleType", 10,  &n->sampleType, newSVpvs("WebGPU::Direct::TextureSampleType"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
viewDimension(THIS, value = NO_INIT)
        WebGPU::Direct::TextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "viewDimension", 13,  &n->viewDimension, newSVpvs("WebGPU::Direct::TextureViewDimension"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
multisampled(THIS, value = NO_INIT)
        WebGPU::Direct::TextureBindingLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "multisampled", 12,  &n->multisampled, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "multisampled", 12,  &n->multisampled, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TextureBindingLayout__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TextureBindingLayout__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUTextureBindingLayout *n = (WGPUTextureBindingLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUTextureBindingLayout) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TextureViewDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
dimension(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureViewDimension"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureViewDimension"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
baseMipLevel(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "baseMipLevel", 12,  &n->baseMipLevel, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "baseMipLevel", 12,  &n->baseMipLevel, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mipLevelCount(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
baseArrayLayer(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "baseArrayLayer", 14,  &n->baseArrayLayer, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "baseArrayLayer", 14,  &n->baseArrayLayer, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
arrayLayerCount(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "arrayLayerCount", 15,  &n->arrayLayerCount, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "arrayLayerCount", 15,  &n->arrayLayerCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
aspect(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
usage(THIS, value = NO_INIT)
        WebGPU::Direct::TextureViewDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TextureViewDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TextureViewDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUTextureViewDescriptor *n = (WGPUTextureViewDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUTextureViewDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::VertexAttribute	PREFIX = wgpu

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::VertexAttribute THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexAttribute *n = (WGPUVertexAttribute *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::VertexFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::VertexFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
offset(THIS, value = NO_INIT)
        WebGPU::Direct::VertexAttribute THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexAttribute *n = (WGPUVertexAttribute *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "offset", 6,  &n->offset, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
shaderLocation(THIS, value = NO_INIT)
        WebGPU::Direct::VertexAttribute THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexAttribute *n = (WGPUVertexAttribute *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "shaderLocation", 14,  &n->shaderLocation, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "shaderLocation", 14,  &n->shaderLocation, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__VertexAttribute__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__VertexAttribute__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUVertexAttribute *n = (WGPUVertexAttribute *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUVertexAttribute) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BindGroupDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
layout(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::BindGroupLayout"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::BindGroupLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
entryCount(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "entryCount", 10,  &n->entryCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
entries(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupEntry"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupEntry"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBindGroupDescriptor *n = (WGPUBindGroupDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBindGroupDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BindGroupLayoutEntry	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
binding(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "binding", 7,  &n->binding, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
visibility(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "visibility", 10,  &n->visibility, newSVpvs("WebGPU::Direct::ShaderStage"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "visibility", 10,  &n->visibility, newSVpvs("WebGPU::Direct::ShaderStage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
buffer(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        WebGPU::Direct::BufferBindingLayout value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "buffer", 6,  &n->buffer, sizeof(n->buffer), newSVpvs("WebGPU::Direct::BufferBindingLayout"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "buffer", 6,  &n->buffer, sizeof(n->buffer), newSVpvs("WebGPU::Direct::BufferBindingLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sampler(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        WebGPU::Direct::SamplerBindingLayout value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "sampler", 7,  &n->sampler, sizeof(n->sampler), newSVpvs("WebGPU::Direct::SamplerBindingLayout"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "sampler", 7,  &n->sampler, sizeof(n->sampler), newSVpvs("WebGPU::Direct::SamplerBindingLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
texture(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        WebGPU::Direct::TextureBindingLayout value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "texture", 7,  &n->texture, sizeof(n->texture), newSVpvs("WebGPU::Direct::TextureBindingLayout"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "texture", 7,  &n->texture, sizeof(n->texture), newSVpvs("WebGPU::Direct::TextureBindingLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
storageTexture(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutEntry THIS
        WebGPU::Direct::StorageTextureBindingLayout value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "storageTexture", 14,  &n->storageTexture, sizeof(n->storageTexture), newSVpvs("WebGPU::Direct::StorageTextureBindingLayout"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "storageTexture", 14,  &n->storageTexture, sizeof(n->storageTexture), newSVpvs("WebGPU::Direct::StorageTextureBindingLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupLayoutEntry__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupLayoutEntry__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBindGroupLayoutEntry *n = (WGPUBindGroupLayoutEntry *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBindGroupLayoutEntry) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BlendState	PREFIX = wgpu

SV *
color(THIS, value = NO_INIT)
        WebGPU::Direct::BlendState THIS
        WebGPU::Direct::BlendComponent value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBlendState *n = (WGPUBlendState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "color", 5,  &n->color, sizeof(n->color), newSVpvs("WebGPU::Direct::BlendComponent"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "color", 5,  &n->color, sizeof(n->color), newSVpvs("WebGPU::Direct::BlendComponent"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
alpha(THIS, value = NO_INIT)
        WebGPU::Direct::BlendState THIS
        WebGPU::Direct::BlendComponent value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBlendState *n = (WGPUBlendState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "alpha", 5,  &n->alpha, sizeof(n->alpha), newSVpvs("WebGPU::Direct::BlendComponent"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "alpha", 5,  &n->alpha, sizeof(n->alpha), newSVpvs("WebGPU::Direct::BlendComponent"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BlendState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BlendState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBlendState *n = (WGPUBlendState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBlendState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::CompilationInfo	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfo *n = (WGPUCompilationInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
messageCount(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfo *n = (WGPUCompilationInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "messageCount", 12,  &n->messageCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
messages(THIS, value = NO_INIT)
        WebGPU::Direct::CompilationInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUCompilationInfo *n = (WGPUCompilationInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "messages", 8, (void **) &n->messages, &n->messageCount, sizeof(*n->messages), newSVpvs("WebGPU::Direct::CompilationMessage"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "messages", 8, (void **) &n->messages, &n->messageCount, sizeof(*n->messages), newSVpvs("WebGPU::Direct::CompilationMessage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CompilationInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__CompilationInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUCompilationInfo *n = (WGPUCompilationInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUCompilationInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ComputePassDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePassDescriptor *n = (WGPUComputePassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePassDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePassDescriptor *n = (WGPUComputePassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
timestampWrites(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePassDescriptor *n = (WGPUComputePassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::ComputePassTimestampWrites"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::ComputePassTimestampWrites"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ComputePassDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ComputePassDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUComputePassDescriptor *n = (WGPUComputePassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUComputePassDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::DepthStencilState	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthWriteEnabled(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "depthWriteEnabled", 17,  &n->depthWriteEnabled, newSVpvs("WebGPU::Direct::OptionalBool"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "depthWriteEnabled", 17,  &n->depthWriteEnabled, newSVpvs("WebGPU::Direct::OptionalBool"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthCompare(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "depthCompare", 12,  &n->depthCompare, newSVpvs("WebGPU::Direct::CompareFunction"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "depthCompare", 12,  &n->depthCompare, newSVpvs("WebGPU::Direct::CompareFunction"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilFront(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        WebGPU::Direct::StencilFaceState value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "stencilFront", 12,  &n->stencilFront, sizeof(n->stencilFront), newSVpvs("WebGPU::Direct::StencilFaceState"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "stencilFront", 12,  &n->stencilFront, sizeof(n->stencilFront), newSVpvs("WebGPU::Direct::StencilFaceState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilBack(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        WebGPU::Direct::StencilFaceState value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "stencilBack", 11,  &n->stencilBack, sizeof(n->stencilBack), newSVpvs("WebGPU::Direct::StencilFaceState"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "stencilBack", 11,  &n->stencilBack, sizeof(n->stencilBack), newSVpvs("WebGPU::Direct::StencilFaceState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilReadMask(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "stencilReadMask", 15,  &n->stencilReadMask, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "stencilReadMask", 15,  &n->stencilReadMask, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
stencilWriteMask(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "stencilWriteMask", 16,  &n->stencilWriteMask, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "stencilWriteMask", 16,  &n->stencilWriteMask, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthBias(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_int32_t(aTHX_ h, "depthBias", 9,  &n->depthBias, NULL);

        if (items > 1)
        {
              _store_int32_t(aTHX_ h, "depthBias", 9,  &n->depthBias, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthBiasSlopeScale(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_float(aTHX_ h, "depthBiasSlopeScale", 19,  &n->depthBiasSlopeScale, NULL);

        if (items > 1)
        {
              _store_float(aTHX_ h, "depthBiasSlopeScale", 19,  &n->depthBiasSlopeScale, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthBiasClamp(THIS, value = NO_INIT)
        WebGPU::Direct::DepthStencilState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_float(aTHX_ h, "depthBiasClamp", 14,  &n->depthBiasClamp, NULL);

        if (items > 1)
        {
              _store_float(aTHX_ h, "depthBiasClamp", 14,  &n->depthBiasClamp, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__DepthStencilState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__DepthStencilState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUDepthStencilState *n = (WGPUDepthStencilState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUDepthStencilState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::DeviceDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
requiredFeatureCount(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "requiredFeatureCount", 20,  &n->requiredFeatureCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
requiredFeatures(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "requiredFeatures", 16, (void **) &n->requiredFeatures, &n->requiredFeatureCount, sizeof(*n->requiredFeatures), newSVpvs("WebGPU::Direct::FeatureName"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "requiredFeatures", 16, (void **) &n->requiredFeatures, &n->requiredFeatureCount, sizeof(*n->requiredFeatures), newSVpvs("WebGPU::Direct::FeatureName"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
requiredLimits(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "requiredLimits", 14, (void **) &n->requiredLimits, newSVpvs("WebGPU::Direct::Limits"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "requiredLimits", 14, (void **) &n->requiredLimits, newSVpvs("WebGPU::Direct::Limits"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
defaultQueue(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        WebGPU::Direct::QueueDescriptor value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "defaultQueue", 12,  &n->defaultQueue, sizeof(n->defaultQueue), newSVpvs("WebGPU::Direct::QueueDescriptor"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "defaultQueue", 12,  &n->defaultQueue, sizeof(n->defaultQueue), newSVpvs("WebGPU::Direct::QueueDescriptor"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
deviceLostCallbackInfo(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        WebGPU::Direct::DeviceLostCallbackInfo value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "deviceLostCallbackInfo", 22,  &n->deviceLostCallbackInfo, sizeof(n->deviceLostCallbackInfo), newSVpvs("WebGPU::Direct::DeviceLostCallbackInfo"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "deviceLostCallbackInfo", 22,  &n->deviceLostCallbackInfo, sizeof(n->deviceLostCallbackInfo), newSVpvs("WebGPU::Direct::DeviceLostCallbackInfo"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
uncapturedErrorCallbackInfo(THIS, value = NO_INIT)
        WebGPU::Direct::DeviceDescriptor THIS
        WebGPU::Direct::UncapturedErrorCallbackInfo value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "uncapturedErrorCallbackInfo", 27,  &n->uncapturedErrorCallbackInfo, sizeof(n->uncapturedErrorCallbackInfo), newSVpvs("WebGPU::Direct::UncapturedErrorCallbackInfo"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "uncapturedErrorCallbackInfo", 27,  &n->uncapturedErrorCallbackInfo, sizeof(n->uncapturedErrorCallbackInfo), newSVpvs("WebGPU::Direct::UncapturedErrorCallbackInfo"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__DeviceDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__DeviceDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUDeviceDescriptor *n = (WGPUDeviceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUDeviceDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::FutureWaitInfo	PREFIX = wgpu

SV *
future(THIS, value = NO_INIT)
        WebGPU::Direct::FutureWaitInfo THIS
        WebGPU::Direct::Future value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFutureWaitInfo *n = (WGPUFutureWaitInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "future", 6,  &n->future, sizeof(n->future), newSVpvs("WebGPU::Direct::Future"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "future", 6,  &n->future, sizeof(n->future), newSVpvs("WebGPU::Direct::Future"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
completed(THIS, value = NO_INIT)
        WebGPU::Direct::FutureWaitInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFutureWaitInfo *n = (WGPUFutureWaitInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "completed", 9,  &n->completed, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "completed", 9,  &n->completed, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__FutureWaitInfo__pack( THIS );
        WebGPU__Direct__Future__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__FutureWaitInfo__unpack( THIS );
        WebGPU__Direct__Future__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUFutureWaitInfo *n = (WGPUFutureWaitInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUFutureWaitInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::InstanceDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::InstanceDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUInstanceDescriptor *n = (WGPUInstanceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
features(THIS, value = NO_INIT)
        WebGPU::Direct::InstanceDescriptor THIS
        WebGPU::Direct::InstanceCapabilities value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUInstanceDescriptor *n = (WGPUInstanceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "features", 8,  &n->features, sizeof(n->features), newSVpvs("WebGPU::Direct::InstanceCapabilities"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "features", 8,  &n->features, sizeof(n->features), newSVpvs("WebGPU::Direct::InstanceCapabilities"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__InstanceDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__InstanceDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUInstanceDescriptor *n = (WGPUInstanceDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUInstanceDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ProgrammableStageDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::ProgrammableStageDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
module(THIS, value = NO_INIT)
        WebGPU::Direct::ProgrammableStageDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
entryPoint(THIS, value = NO_INIT)
        WebGPU::Direct::ProgrammableStageDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
constantCount(THIS, value = NO_INIT)
        WebGPU::Direct::ProgrammableStageDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "constantCount", 13,  &n->constantCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
constants(THIS, value = NO_INIT)
        WebGPU::Direct::ProgrammableStageDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ProgrammableStageDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ProgrammableStageDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUProgrammableStageDescriptor *n = (WGPUProgrammableStageDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUProgrammableStageDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPassColorAttachment	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
view(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "view", 4, (void **) &n->view, newSVpvs("WebGPU::Direct::TextureView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthSlice(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "depthSlice", 10,  &n->depthSlice, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "depthSlice", 10,  &n->depthSlice, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
resolveTarget(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "resolveTarget", 13, (void **) &n->resolveTarget, newSVpvs("WebGPU::Direct::TextureView"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "resolveTarget", 13, (void **) &n->resolveTarget, newSVpvs("WebGPU::Direct::TextureView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
loadOp(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "loadOp", 6,  &n->loadOp, newSVpvs("WebGPU::Direct::LoadOp"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "loadOp", 6,  &n->loadOp, newSVpvs("WebGPU::Direct::LoadOp"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
storeOp(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "storeOp", 7,  &n->storeOp, newSVpvs("WebGPU::Direct::StoreOp"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "storeOp", 7,  &n->storeOp, newSVpvs("WebGPU::Direct::StoreOp"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
clearValue(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassColorAttachment THIS
        WebGPU::Direct::Color value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "clearValue", 10,  &n->clearValue, sizeof(n->clearValue), newSVpvs("WebGPU::Direct::Color"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "clearValue", 10,  &n->clearValue, sizeof(n->clearValue), newSVpvs("WebGPU::Direct::Color"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassColorAttachment__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassColorAttachment__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderPassColorAttachment *n = (WGPURenderPassColorAttachment *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderPassColorAttachment) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TexelCopyBufferInfo	PREFIX = wgpu

SV *
layout(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyBufferInfo THIS
        WebGPU::Direct::TexelCopyBufferLayout value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyBufferInfo *n = (WGPUTexelCopyBufferInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "layout", 6,  &n->layout, sizeof(n->layout), newSVpvs("WebGPU::Direct::TexelCopyBufferLayout"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "layout", 6,  &n->layout, sizeof(n->layout), newSVpvs("WebGPU::Direct::TexelCopyBufferLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
buffer(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyBufferInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyBufferInfo *n = (WGPUTexelCopyBufferInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "buffer", 6, (void **) &n->buffer, newSVpvs("WebGPU::Direct::Buffer"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TexelCopyBufferInfo__pack( THIS );
        WebGPU__Direct__TexelCopyBufferLayout__pack( /*asdf*/ THIS );
 //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TexelCopyBufferInfo__unpack( THIS );
        WebGPU__Direct__TexelCopyBufferLayout__unpack( /*asdf*/ THIS );
 //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUTexelCopyBufferInfo *n = (WGPUTexelCopyBufferInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUTexelCopyBufferInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TexelCopyTextureInfo	PREFIX = wgpu

SV *
texture(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyTextureInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "texture", 7, (void **) &n->texture, newSVpvs("WebGPU::Direct::Texture"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mipLevel(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyTextureInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "mipLevel", 8,  &n->mipLevel, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "mipLevel", 8,  &n->mipLevel, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
origin(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyTextureInfo THIS
        WebGPU::Direct::Origin3D value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "origin", 6,  &n->origin, sizeof(n->origin), newSVpvs("WebGPU::Direct::Origin3D"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "origin", 6,  &n->origin, sizeof(n->origin), newSVpvs("WebGPU::Direct::Origin3D"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
aspect(THIS, value = NO_INIT)
        WebGPU::Direct::TexelCopyTextureInfo THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "aspect", 6,  &n->aspect, newSVpvs("WebGPU::Direct::TextureAspect"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TexelCopyTextureInfo__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TexelCopyTextureInfo__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUTexelCopyTextureInfo *n = (WGPUTexelCopyTextureInfo *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUTexelCopyTextureInfo) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::TextureDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
usage(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "usage", 5,  &n->usage, newSVpvs("WebGPU::Direct::TextureUsage"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
dimension(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureDimension"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "dimension", 9,  &n->dimension, newSVpvs("WebGPU::Direct::TextureDimension"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
size(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        WebGPU::Direct::Extent3D value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "size", 4,  &n->size, sizeof(n->size), newSVpvs("WebGPU::Direct::Extent3D"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "size", 4,  &n->size, sizeof(n->size), newSVpvs("WebGPU::Direct::Extent3D"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
mipLevelCount(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "mipLevelCount", 13,  &n->mipLevelCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
sampleCount(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL);

        if (items > 1)
        {
              _store_uint32_t(aTHX_ h, "sampleCount", 11,  &n->sampleCount, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
viewFormatCount(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "viewFormatCount", 15,  &n->viewFormatCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
viewFormats(THIS, value = NO_INIT)
        WebGPU::Direct::TextureDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "viewFormats", 11, (void **) &n->viewFormats, &n->viewFormatCount, sizeof(*n->viewFormats), newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TextureDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__TextureDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUTextureDescriptor *n = (WGPUTextureDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUTextureDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::VertexBufferLayout	PREFIX = wgpu

SV *
stepMode(THIS, value = NO_INIT)
        WebGPU::Direct::VertexBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "stepMode", 8,  &n->stepMode, newSVpvs("WebGPU::Direct::VertexStepMode"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "stepMode", 8,  &n->stepMode, newSVpvs("WebGPU::Direct::VertexStepMode"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
arrayStride(THIS, value = NO_INIT)
        WebGPU::Direct::VertexBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_uint64_t(aTHX_ h, "arrayStride", 11,  &n->arrayStride, NULL);

        if (items > 1)
        {
              _store_uint64_t(aTHX_ h, "arrayStride", 11,  &n->arrayStride, NULL, value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
attributeCount(THIS, value = NO_INIT)
        WebGPU::Direct::VertexBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "attributeCount", 14,  &n->attributeCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
attributes(THIS, value = NO_INIT)
        WebGPU::Direct::VertexBufferLayout THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "attributes", 10, (void **) &n->attributes, &n->attributeCount, sizeof(*n->attributes), newSVpvs("WebGPU::Direct::VertexAttribute"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "attributes", 10, (void **) &n->attributes, &n->attributeCount, sizeof(*n->attributes), newSVpvs("WebGPU::Direct::VertexAttribute"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__VertexBufferLayout__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__VertexBufferLayout__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUVertexBufferLayout *n = (WGPUVertexBufferLayout *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUVertexBufferLayout) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::BindGroupLayoutDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
entryCount(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "entryCount", 10,  &n->entryCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
entries(THIS, value = NO_INIT)
        WebGPU::Direct::BindGroupLayoutDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupLayoutEntry"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "entries", 7, (void **) &n->entries, &n->entryCount, sizeof(*n->entries), newSVpvs("WebGPU::Direct::BindGroupLayoutEntry"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupLayoutDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__BindGroupLayoutDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUBindGroupLayoutDescriptor *n = (WGPUBindGroupLayoutDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUBindGroupLayoutDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ColorTargetState	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::ColorTargetState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
format(THIS, value = NO_INIT)
        WebGPU::Direct::ColorTargetState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"));

        if (items > 1)
        {
              _store_enum(aTHX_ h, "format", 6,  &n->format, newSVpvs("WebGPU::Direct::TextureFormat"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
blend(THIS, value = NO_INIT)
        WebGPU::Direct::ColorTargetState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "blend", 5, (void **) &n->blend, newSVpvs("WebGPU::Direct::BlendState"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "blend", 5, (void **) &n->blend, newSVpvs("WebGPU::Direct::BlendState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
writeMask(THIS, value = NO_INIT)
        WebGPU::Direct::ColorTargetState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_flag(aTHX_ h, "writeMask", 9,  &n->writeMask, newSVpvs("WebGPU::Direct::ColorWriteMask"));

        if (items > 1)
        {
              _store_flag(aTHX_ h, "writeMask", 9,  &n->writeMask, newSVpvs("WebGPU::Direct::ColorWriteMask"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ColorTargetState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ColorTargetState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUColorTargetState *n = (WGPUColorTargetState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUColorTargetState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::ComputePipelineDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePipelineDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePipelineDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
layout(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePipelineDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
compute(THIS, value = NO_INIT)
        WebGPU::Direct::ComputePipelineDescriptor THIS
        WebGPU::Direct::ProgrammableStageDescriptor value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "compute", 7,  &n->compute, sizeof(n->compute), newSVpvs("WebGPU::Direct::ProgrammableStageDescriptor"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "compute", 7,  &n->compute, sizeof(n->compute), newSVpvs("WebGPU::Direct::ProgrammableStageDescriptor"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ComputePipelineDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__ComputePipelineDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUComputePipelineDescriptor *n = (WGPUComputePipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUComputePipelineDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPassDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
colorAttachmentCount(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "colorAttachmentCount", 20,  &n->colorAttachmentCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
colorAttachments(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "colorAttachments", 16, (void **) &n->colorAttachments, &n->colorAttachmentCount, sizeof(*n->colorAttachments), newSVpvs("WebGPU::Direct::RenderPassColorAttachment"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "colorAttachments", 16, (void **) &n->colorAttachments, &n->colorAttachmentCount, sizeof(*n->colorAttachments), newSVpvs("WebGPU::Direct::RenderPassColorAttachment"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthStencilAttachment(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "depthStencilAttachment", 22, (void **) &n->depthStencilAttachment, newSVpvs("WebGPU::Direct::RenderPassDepthStencilAttachment"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "depthStencilAttachment", 22, (void **) &n->depthStencilAttachment, newSVpvs("WebGPU::Direct::RenderPassDepthStencilAttachment"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
occlusionQuerySet(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "occlusionQuerySet", 17, (void **) &n->occlusionQuerySet, newSVpvs("WebGPU::Direct::QuerySet"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "occlusionQuerySet", 17, (void **) &n->occlusionQuerySet, newSVpvs("WebGPU::Direct::QuerySet"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
timestampWrites(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPassDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::RenderPassTimestampWrites"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "timestampWrites", 15, (void **) &n->timestampWrites, newSVpvs("WebGPU::Direct::RenderPassTimestampWrites"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPassDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderPassDescriptor *n = (WGPURenderPassDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderPassDescriptor) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::VertexState	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
module(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
entryPoint(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
constantCount(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "constantCount", 13,  &n->constantCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
constants(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
bufferCount(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "bufferCount", 11,  &n->bufferCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
buffers(THIS, value = NO_INIT)
        WebGPU::Direct::VertexState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "buffers", 7, (void **) &n->buffers, &n->bufferCount, sizeof(*n->buffers), newSVpvs("WebGPU::Direct::VertexBufferLayout"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "buffers", 7, (void **) &n->buffers, &n->bufferCount, sizeof(*n->buffers), newSVpvs("WebGPU::Direct::VertexBufferLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__VertexState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__VertexState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUVertexState *n = (WGPUVertexState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUVertexState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::FragmentState	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
module(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "module", 6, (void **) &n->module, newSVpvs("WebGPU::Direct::ShaderModule"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
entryPoint(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "entryPoint", 10,  &n->entryPoint, sizeof(n->entryPoint), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
constantCount(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "constantCount", 13,  &n->constantCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
constants(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "constants", 9, (void **) &n->constants, &n->constantCount, sizeof(*n->constants), newSVpvs("WebGPU::Direct::ConstantEntry"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
targetCount(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_size_t(aTHX_ h, "targetCount", 11,  &n->targetCount, NULL);

        SvREFCNT_inc(RETVAL);

    OUTPUT:
        RETVAL

SV *
targets(THIS, value = NO_INIT)
        WebGPU::Direct::FragmentState THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objarray(aTHX_ h, "targets", 7, (void **) &n->targets, &n->targetCount, sizeof(*n->targets), newSVpvs("WebGPU::Direct::ColorTargetState"));

        if (items > 1)
        {
              _store_objarray(aTHX_ h, "targets", 7, (void **) &n->targets, &n->targetCount, sizeof(*n->targets), newSVpvs("WebGPU::Direct::ColorTargetState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__FragmentState__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__FragmentState__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPUFragmentState *n = (WGPUFragmentState *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPUFragmentState) );
    OUTPUT:
        RETVAL


MODULE = WebGPU::Direct	PACKAGE = WebGPU::Direct::RenderPipelineDescriptor	PREFIX = wgpu

SV *
nextInChain(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "nextInChain", 11, (void **) &n->nextInChain, newSVpvs("WebGPU::Direct::ChainedStruct"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
label(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        WebGPU::Direct::StringView value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "label", 5,  &n->label, sizeof(n->label), newSVpvs("WebGPU::Direct::StringView"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
layout(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"));

        if (items > 1)
        {
              _store_opaque(aTHX_ h, "layout", 6, (void **) &n->layout, newSVpvs("WebGPU::Direct::PipelineLayout"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
vertex(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        WebGPU::Direct::VertexState value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "vertex", 6,  &n->vertex, sizeof(n->vertex), newSVpvs("WebGPU::Direct::VertexState"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "vertex", 6,  &n->vertex, sizeof(n->vertex), newSVpvs("WebGPU::Direct::VertexState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
primitive(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        WebGPU::Direct::PrimitiveState value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "primitive", 9,  &n->primitive, sizeof(n->primitive), newSVpvs("WebGPU::Direct::PrimitiveState"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "primitive", 9,  &n->primitive, sizeof(n->primitive), newSVpvs("WebGPU::Direct::PrimitiveState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
depthStencil(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "depthStencil", 12, (void **) &n->depthStencil, newSVpvs("WebGPU::Direct::DepthStencilState"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "depthStencil", 12, (void **) &n->depthStencil, newSVpvs("WebGPU::Direct::DepthStencilState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
multisample(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        WebGPU::Direct::MultisampleState value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_obj(aTHX_ h, "multisample", 11,  &n->multisample, sizeof(n->multisample), newSVpvs("WebGPU::Direct::MultisampleState"));

        if (items > 1)
        {
              _store_obj(aTHX_ h, "multisample", 11,  &n->multisample, sizeof(n->multisample), newSVpvs("WebGPU::Direct::MultisampleState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

SV *
fragment(THIS, value = NO_INIT)
        WebGPU::Direct::RenderPipelineDescriptor THIS
        SV * value
    PROTOTYPE: $;$
    CODE:
        HV *h = (HV *)SvRV(THIS);
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL =   _find_objptr(aTHX_ h, "fragment", 8, (void **) &n->fragment, newSVpvs("WebGPU::Direct::FragmentState"));

        if (items > 1)
        {
              _store_objptr(aTHX_ h, "fragment", 8, (void **) &n->fragment, newSVpvs("WebGPU::Direct::FragmentState"), value);

        }
        else
        {
            SvREFCNT_inc(RETVAL);
        }


    OUTPUT:
        RETVAL

void
pack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPipelineDescriptor__pack( THIS );
         //

void
unpack(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WebGPU__Direct__RenderPipelineDescriptor__unpack( THIS );
         //

SV *
bytes(THIS)
        SV *THIS
    PROTOTYPE: $
    CODE:
        WGPURenderPipelineDescriptor *n = (WGPURenderPipelineDescriptor *) _get_struct_ptr(aTHX, THIS, NULL);
        RETVAL = newSVpvn((const char *const) n, sizeof(WGPURenderPipelineDescriptor) );
    OUTPUT:
        RETVAL

